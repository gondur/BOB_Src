/*
	 Battle of Britain
	 Copyright (C) 2000, 2001 Empire Interactive (Europe) Ltd,
	 677 High Road, North Finchley, London N12 0DA

	 Please see the document licence.doc for the full licence agreement

2. LICENCE
 2.1 	
 	Subject to the provisions of this Agreement we now grant to you the 
 	following rights in respect of the Source Code:
  2.1.1 
  	the non-exclusive right to Exploit  the Source Code and Executable 
  	Code on any medium; and 
  2.1.2 
  	the non-exclusive right to create and distribute Derivative Works.
 2.2 	
 	Subject to the provisions of this Agreement we now grant you the
	following rights in respect of the Object Code:
  2.2.1 
	the non-exclusive right to Exploit the Object Code on the same
	terms and conditions set out in clause 3, provided that any
	distribution is done so on the terms of this Agreement and is
	accompanied by the Source Code and Executable Code (as
	applicable).

3. GENERAL OBLIGATIONS
 3.1 
 	In consideration of the licence granted in clause 2.1 you now agree:
  3.1.1 
	that when you distribute the Source Code or Executable Code or
	any Derivative Works to Recipients you will also include the
	terms of this Agreement;
  3.1.2 
	that when you make the Source Code, Executable Code or any
	Derivative Works ("Materials") available to download, you will
	ensure that Recipients must accept the terms of this Agreement
	before being allowed to download such Materials;
  3.1.3 
	that by Exploiting the Source Code or Executable Code you may
	not impose any further restrictions on a Recipient's subsequent
	Exploitation of the Source Code or Executable Code other than
	those contained in the terms and conditions of this Agreement;
  3.1.4 
	not (and not to allow any third party) to profit or make any
	charge for the Source Code, or Executable Code, any
	Exploitation of the Source Code or Executable Code, or for any
	Derivative Works;
  3.1.5 
	not to place any restrictions on the operability of the Source 
	Code;
  3.1.6 
	to attach prominent notices to any Derivative Works stating
	that you have changed the Source Code or Executable Code and to
	include the details anddate of such change; and
  3.1.7 
  	not to Exploit the Source Code or Executable Code otherwise than
	as expressly permitted by  this Agreement.

questions about this file may be asked at bob@rowansoftware.com a
better place to ask is http://www.simhq.com/ or even :-
http://www.simhq.com/cgi-bin/boards/cgi-bin/forumdisplay.cgi?action=topics&forum=Battle+of+Britain&number=40&DaysPrune=20&LastLogin=
*/

//------------------------------------------------------------------------------
//Filename       comms.cpp
//Description    All Comms Init Stuff Prior to Sending Init Packets
//------------------------------------------------------------------------------
#define	F_COMMON
#define IDIRECTPLAY2_OR_GREATER
#include	"DOSDefs.H"
#include	<stdio.h>
#include	<stdlib.h>

#include 	<windows.h>
#include	"dplay.h"
#include	"dplobby.h"

#include	"myerror.h"

#include	"worldinc.h"
#include	"uniqueID.h"
#include	"files.g"
#include	"3dinstr.h"
#include	"savegame.h"
#include	"winmove.h"


#include	"misssub.h"
#include	"comms.h"

#include	"cbuffer.h"
#include	"aggrgtor.h"
#include	"missman2.h"
#include	"Mytime.h"
#include	"globrefs.h"
#include	"stub3d.h"
#include	"ctimeout.h"
#include	"..\mfc\resource.h"
#include	"replay.h"
#include	"bstream.h"
#include	"rchatter.h"
#include	"persons2.h"
#include	"overlay.h"
#include	"miles.h"
#include	"mymath.h"

//#include	"persons2.h"
//#include	"ui.h"

//#define TEMPTIMEOUT 3000
//#define CTRACE
//#define HOSTGO

//STATICS!!!

H2HPlayerInfo DPlay::H2H_Player[MAXPLAYERS];

DPlay _DPlay;

//NOTE: the following GUID was generated by guidgen.exe
// {38305683-01EB-11d2-B1A4-004005247C2D}

// for lobbied games the GUID defined here is not used, the registry entry is instead
// used to find games. This must be altered by the install program.

//MOVED TO GENERAL\STATIC.CPP
#ifndef	BOB_DEMO_VER
DEFINE_GUID(BOB_GUID); 
//DEFINE_GUID(MIGALLEY_GUID); 
//0x38305683, 0x1eb, 0x11d2, 0xb1, 0xa4, 0x0, 0x40, 0x5, 0x24, 0x7c, 0x3d);
#else
DEFINE_GUID(BOB_GUID); 
//DEFINE_GUID(MIGALLEY_GUID); 
//0x38305683, 0x1eb, 0x11d2, 0xb1, 0xa4, 0x0, 0x40, 0x5, 0x24, 0x7c, 0x4d);
#endif 

// Callback Functions	

BOOL WINAPI	EnumConnectionsCallback(LPCGUID lpguidSP, LPVOID lpConnection, DWORD dwConnectionSize,
									LPCDPNAME lpName, DWORD dwFlags, LPVOID pContext);

BOOL WINAPI EnumSessionsCallback(LPCDPSESSIONDESC2 lpSessionDesc, LPDWORD lpdwTimeOut,
								DWORD dwFlags, LPVOID lpContext);

BOOL WINAPI EnumSessionsDataCallback(LPCDPSESSIONDESC2 lpSessionDesc, LPDWORD lpdwTimeOut,
								DWORD dwFlags, LPVOID lpContext);

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		ExitDirectPlay
//Date			Fri 9 Aug 1996
//Description	exits DirectPlay Nice & Clean
//------------------------------------------------------------------------------
void DPlay::ExitDirectPlay ()
{
	PlayerCreated = FALSE;
	Implemented = FALSE;
	singlesession=false;
	SideSelected=false;
	Host=FALSE;
	csync=false;	

	delete [] CommsPacketPtr;
	CommsPacketPtr=NULL;
	CommsPacketLength=0;

	lpAppGuid=NULL;

	if (lpDP4)
	{
		lpDP4->CancelMessage(0,0);
		lpDP4->Close();
		lpDP4->Release();
		lpDP4=NULL;
	}

	DeleteAIACPositionsList();

	DeleteSessionList();

	DeleteServiceList();

	DeleteLobbyInfo();

	ClearDeadPilots();
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		UIMultiPlayInit
//Date			Thu 27 Nov 1997
//------------------------------------------------------------------------------
Bool DPlay::UIMultiPlayInit ()
{
	Lobbied=FALSE;

	if (!CreateDPlayInterface())
		return FALSE;

	return TRUE;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		UISelectServiceProvider
//Date			Wed 9 Jul 1997
//------------------------------------------------------------------------------
Bool DPlay::UISelectServiceProvider(char* servicename)
{
	HRESULT res=DPERR_INVALIDPARAMS;
	LPENUMSERVICE temp;

	temp=ServiceList;

	while (temp)
	{
		if (!strcmp(servicename,temp->sname))
		{
			res=lpDP4->InitializeConnection(temp->connection,0);

			if (res==DP_OK)
			{
				if (temp->sid==DPSPGUID_MODEM)
				{
// special setup code for modem

					RateDivider=3;
 					CommsTimeoutLength=20000;
					singlesession=false;
				}
				else if (temp->sid==DPSPGUID_TCPIP)
				{
// special setup code for internet

					RateDivider=3;
					CommsTimeoutLength=20000;
					singlesession=false;
				}
				else if (temp->sid==DPSPGUID_SERIAL)
				{
// special setup code for serial

					RateDivider=1;
					CommsTimeoutLength=5000;
					singlesession=true;
				}
				else if (temp->sid==DPSPGUID_IPX)
				{
// special setup code for network

					RateDivider=2;
					CommsTimeoutLength=50000;
					singlesession=false;
				}
				else
				{
// others - treat as internet

					RateDivider=3;
					CommsTimeoutLength=20000;
					singlesession=false;
				}
			}
			break;
		}
		temp=temp->Next;
	}

	if (res!=DP_OK)										
		return FALSE;

	return TRUE;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		UIGetSessionListUpdate
//Date			Tue 24 Sep 1996
//Description	Obtain and insert into list all sessions
//------------------------------------------------------------------------------
bool DPlay::UIGetSessionListUpdate ()
{
	HRESULT res=DP_OK;						
	DPSESSIONDESC2 DPSessionDesc2;

	DeleteSessionList();

	ZeroMemory( &DPSessionDesc2,sizeof(DPSESSIONDESC2));

	DPSessionDesc2.dwSize = sizeof (DPSESSIONDESC2);
 	DPSessionDesc2.guidApplication=*lpAppGuid;					

	if (lpDP4)
		res = lpDP4->EnumSessions (
			(LPDPSESSIONDESC2)&DPSessionDesc2,
			(DWORD)0,
			EnumSessionsCallback,
			(LPVOID)NULL,
			(DWORD)(DPENUMSESSIONS_AVAILABLE|DPENUMSESSIONS_ASYNC)
			);

	if (res!=DP_OK) 
		return false;

	return true;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		UIAssignServices
//Date			Fri 18 Jul 1997
//------------------------------------------------------------------------------
bool DPlay::UIAssignServices()
{
	HRESULT res;

	DeleteServiceList();

	res=lpDP4->EnumConnections(lpAppGuid,EnumConnectionsCallback,NULL,0);

	if (res!=DP_OK)
		return false;

	return true;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		UINewPlayer
//Date			Mon 23 Sep 1996
//Description	Create a new player - from enter name in UI
//------------------------------------------------------------------------------
Bool DPlay::UINewPlayer (char* Name, char* SessionName)
{
	HRESULT res;
	DPSESSIONDESC2 DPSessionDesc2;

// check if name is null - if so abort

	if (!strlen(Name))
		return FALSE;

	if (UIPlayerType==PLAYER_HOST)
	{
// fill out dpsessiondesc2 struc

		ZeroMemory(&DPSessionDesc2, sizeof(DPSESSIONDESC2));

		DPSessionDesc2.dwSize = sizeof (DPSESSIONDESC2);
		DPSessionDesc2.dwMaxPlayers = MAXPLAYERS+1;	 // allow for aggregator
		DPSessionDesc2.guidApplication=*lpAppGuid;				
		DPSessionDesc2.dwCurrentPlayers=0;

		DPSessionDesc2.lpszSessionNameA=new char[PLAYERNAMELEN];
		strcpy( DPSessionDesc2.lpszSessionNameA, _DPlay.SessionName);
		
		
// create session

		DPSessionDesc2.dwFlags|=DPSESSION_DIRECTPLAYPROTOCOL	// need asyncronous send
								|DPSESSION_KEEPALIVE			// keep track of player falling out
								| DPSESSION_OPTIMIZELATENCY; // no nagling
								
		res=lpDP4->Open(&DPSessionDesc2,DPOPEN_CREATE);

		delete [] DPSessionDesc2.lpszSessionNameA;

		if (res!=DP_OK)
			return FALSE;

// myPlayerID is the Host in the session

		Host = TRUE;
	}
	else if (UIPlayerType==PLAYER_GUEST)
	{
// check if session name is null - if so abort

		if (!strlen(SessionName))
			return FALSE;
	
// Connect to an existing Session

		ZeroMemory( &DPSessionDesc2, sizeof(DPSESSIONDESC2));

		DPSessionDesc2.dwSize = sizeof (DPSESSIONDESC2);

		DPSessionDesc2.guidApplication = *lpAppGuid;
		DPSessionDesc2.lpszSessionNameA=new char[PLAYERNAMELEN];
		strcpy( DPSessionDesc2.lpszSessionNameA, _DPlay.SessionName);
		
// get session data

		res = lpDP4->EnumSessions (
			(LPDPSESSIONDESC2)&DPSessionDesc2,
			(DWORD)0,
			EnumSessionsDataCallback,
			(LPVOID)SessionName,
			(DWORD)(DPENUMSESSIONS_AVAILABLE|DPENUMSESSIONS_ASYNC)
			);

		delete [] DPSessionDesc2.lpszSessionNameA;

		if (tempdpsessdesc2!=NULL)
		{
			CopyMemory(&DPSessionDesc2,tempdpsessdesc2,sizeof(DPSESSIONDESC2));
			delete [] tempdpsessdesc2;
			tempdpsessdesc2=NULL;
		}

		if (res!=DP_OK)
			return FALSE;

		res=lpDP4->Open ( &DPSessionDesc2,DPOPEN_JOIN );

		if (res!=DP_OK)
			return FALSE;

		Host = FALSE;
	}
	else
		return FALSE;

// Create a player

	if (!SetUpPlayer())
		return FALSE;

	return TRUE;
}

//------------------------------------------------------------------------------
//Procedure		UIUpdateMainSheet
//Date			Wed 25 Sep 1996
//Description	Update Main Sheet with player details
//------------------------------------------------------------------------------
void DPlay::UIUpdateMainSheet ()
{
	char* RecPacket;
	ULong RecPacketLen=0;
	ULong n,from;
	Bool	stop=TRUE;
	Bool	retval;

// if we are on way out then dont bother to do anything (especially process messages - ohno..)

	if (LeaveCommsFlag)
		return;

// make sure status is not 3D!									

	Implemented=FALSE;

// if we are ready to go then dont receive any messages here, wait till
// selectfly !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

	if (FlyNowFlag)
		return;

	for (n=0;n<MAXPLAYERS;n++)
	{
		if ((H2H_Player+n)->status==CPS_3D)
			stop=FALSE;
	}

	if (stop)
	{
		GameRunning=FALSE;
	}

	while (ReceiveNextMessageToMe(RecPacket,RecPacketLen,from,DPRECEIVE_TOPLAYER))
	{
		if (from==DPID_SYSMSG)
			retval=ProcessSystemMessage(RecPacket);
		else
		{
// if aggregated packet ignore 

			if (from!=aggID)
			{
				retval=ProcessPlayerMessage(RecPacket,RecPacketLen,from);
				if (!retval) 
					break;
			}
		}
	}

	if (Host)
		EmptyAggregatorQueue();

	if (MainSheetCount) 
	{
// First time in

		InitMainSheetInfo();
		MainSheetCount=0;
	}
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		UILeavingMainSheet
//Date			Wed 25 Sep 1996
//Description	Player leaves main Sheet
//------------------------------------------------------------------------------
void DPlay::UILeavingMainSheet ()
{
	if (PlayerCreated)
	{
// Send Player leaving packet

		GENERIC data;

		data.PacketID=PID_PLAYERQUIT;
		data.PlayerID=myDPlayID;

// dont send leaving message guaranteed, no point, dont care if they dont get it, game is over

// dont send async either so that all messages can be cancelled easily

		lpDP4->SendEx (myDPlayID,playergroupID,DPSEND_NOSENDCOMPLETEMSG,&data,sizeof(GENERIC),0,0,NULL,NULL);

		MyTeamKills=0;
		MyTeamDeaths=0;
		EnemyTeamKills=0;
		EnemyTeamDeaths=0;

		if (!Host)
			_Replay.RestorePrefs(true);
		else
			RestoreHostPrefs();
	}
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		UISendPrefs
//Date			Fri 4 Oct 1996
//------------------------------------------------------------------------------
Bool DPlay::UISendPrefs (ULong to)
{
	UIPREFSDATA UIPrefsData;

// Only send prefs if I am the host

	if (PlayerCreated && Host)
	{
		UIPrefsData.PacketID = PID_PREFSDATA;

		UIPrefsData.PlayerID = myDPlayID;

		Save_Data.gamedifficulty|=GD_VULNERABLE;
		Save_Data.gamedifficulty|=GD_GROUNDCOLLISIONS;

		Save_Data.gamedifficulty|=GD_COLLISIONS;			

// dont want any engine management in comms, ever.

		Save_Data.flightdifficulty%=FD_ENGINEMANAGMENT;

		UIPrefsData.flightdifficulty	=	Save_Data.flightdifficulty;
		UIPrefsData.gamedifficulty		=	Save_Data.gamedifficulty;
		UIPrefsData.targetsize			=	Save_Data.targetsize;
		UIPrefsData.autopilotskillLW	= 	Save_Data.autopilotskillLW;
		UIPrefsData.autopilotskillRAF	= 	Save_Data.autopilotskillRAF;

		UIPrefsData.GEffects=Save_Data.hardwareconfig[HW_GEFFECTS];
		UIPrefsData.InjuryEffects=Save_Data.hardwareconfig[HW_INJURYEFFECTS];
		UIPrefsData.WhiteOuts=Save_Data.hardwareconfig[HW_WHITEOUT];
		UIPrefsData.ACNames=Save_Data.detail_3d[DETAIL3D_PADLOCKCHEAT];
		UIPrefsData.Clouds=Save_Data.hardwareconfig[HW_FLUFFYCLOUDS];

		if (SendMessageToPlayer((char*)&UIPrefsData,sizeof(UIPREFSDATA),to))
			return TRUE;
	}
	return FALSE;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		UISendDialogue
//Date			Fri 27 Sep 1996
//------------------------------------------------------------------------------
void DPlay::UISendDialogue (char* Text)
{
	UIPLAYERDATA UIPlayerData;
	ULong UIPlayerSize;

// truncate text to 100 chars

	strncpy( &((H2H_Player+mySlot)->dialogue[0]),Text,99);
	H2H_Player[mySlot].dialogue[99]='\0';

	CopyMemory((char*)(&UIPlayerData.playerinfo),(char*)(H2H_Player+mySlot),sizeof(H2HPlayerInfo));

// nobble playerid for use as send to all/my team switch

	UIPlayerData.PlayerID=sendtowho;

	UIPlayerData.PacketID = PID_MESSAGE;

	UIPlayerSize = sizeof (UIPLAYERDATA);

	SendMessageToGroup((char*)&UIPlayerData,UIPlayerSize);
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		UINetworkSelectFly
//Date			Mon 23 Sep 1996
//Description	Network Fly Selection
//------------------------------------------------------------------------------
Bool DPlay::UINetworkSelectFly ()
{
	HRESULT res;
	UIPLAYERDATA UIPlayerData;
	ULong UIPlayerSize;
	char* RecPacket;
	ULong RecPacketLen,From;
	H2HPlayerInfo* thisH2H_Player;
	ULong	n;

#ifdef CTRACE
	FILE* fp=fopen("ctrace.txt","at");
	fprintf(fp,"UINetworkSelectFly\n");
	fprintf(fp,"==================\n");
#endif


	CountPlayers(false);									
															
	if (Host)												
	{														
		if (GameType>TEAMPLAY)								
		{													
			if (!AllPlayersHaveSlots())						
			{												
				CommsMessage(IDS_NOTSLOTS);					
				return FALSE;								
			}												
		}													
		else												
		{													
			for (n=0;n<MAXPLAYERS;n++)						
			{												
				if (H2H_Player[n].status!=CPS_NONE && H2H_Player[n].status!=CPS_READYROOM)
					return FALSE;								
			}													
		}														
	}															

	if (!PlayerCreated)
	{
#ifdef CTRACE
		fprintf(fp,"PlayerNotCreated\n");
		fclose(fp);
#endif
		return FALSE;
	}

	Joining=FALSE;
	JustJoined=FALSE;
	SimulateExitKey=FALSE;

	ResetAllocPacket();

		ClearPackages();

	if (Host)
	{
		if (!UISendFlyNow())
 		{
#ifdef CTRACE
			fprintf(fp,"SendFlyNow message failed\n");
			fclose(fp);
#endif
			return FALSE;
		}

		if (!GetAllGoResponses())
			return FALSE;
		else
			SendHostGo();
	}
	else
	{
		SendGoResponse();

		if (!GetHostGo())
			return FALSE;
	}
#ifdef CTRACE
		fprintf(fp,"begin info collection\n");
		fflush(fp);
#endif

// all dudes are in 3d

	for (n=0;n<MAXPLAYERS;n++)
	{
		if (H2H_Player[n].status!=CPS_NONE)
		{
			H2H_Player[n].status=CPS_3D;
		}
// set all scores to 0 for a new game

		H2H_Player[n].kills=0;
		H2H_Player[n].deaths=0;
		H2H_Player[n].assists=0;
		MyTeamKills=0;		
		MyTeamDeaths=0;
		EnemyTeamKills=0;		
		EnemyTeamDeaths=0;
	}

	csync=false;

	UpdateMessages();

	if (GameType<COMMSQUICKMISSION)
	{
		if (!UpdateMissionConditions())
		{
#ifdef CTRACE
			fprintf(fp,"updatemissionconds FAILED\n");
			fclose(fp);
#endif
			return FALSE;
		}
	}

	if (GameType==COMMSQUICKMISSION)
	{
		if (Host)
		{
			if (!SendCampaignStruc(false))
			{
				return FALSE;
			}
		}
		else
		{
			if (!ReceiveCampaignStruc())
			{
				return FALSE;
			}
		}
	}

#ifdef CTRACE
	fclose(fp);
#endif

	ULong	squads[PT_GER_NONFLY+1];

	if (GameType<COMMSQUICKMISSION)
	{
		FillCSQuickStruc();

// position 

		for (n=0;n<=PT_GER_NONFLY;n++)
		{
			squads[n]=0;
		}

		for (n=0;n<MAXPLAYERS;n++)
		{
			H2H_Player[n].position=squads[H2H_Player[n].squadron];
			squads[H2H_Player[n].squadron]++;
		}
	}

	MMC.playersquadron=H2H_Player[mySlot].squadron;
	MMC.playeracnum=H2H_Player[mySlot].position;

	GR_amberstrength = MAXPLAYERS;

	InitialFlagReset();

	return TRUE;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		DeleteServiceList
//Date			Mon 21 Jul 1997
//------------------------------------------------------------------------------
void DPlay::DeleteServiceList()
{
	LPENUMSERVICE temp1,temp2;
	temp1=ServiceList;

	while (temp1)
	{
		delete[]temp1->sname;
		delete[]temp1->connection;

		temp2=temp1->Next;
		temp1->Next=NULL;

		delete temp1;

		temp1=temp2;
	}
	ServiceList=NULL;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		CreateDPlayInterface
//Date			Wed 26 Nov 1997
//------------------------------------------------------------------------------
Bool	DPlay::CreateDPlayInterface()
{
	HRESULT res;

	res = CoCreateInstance( CLSID_DirectPlay, NULL, CLSCTX_INPROC_SERVER, 
		IID_IDirectPlay4A, (LPVOID*)&lpDP4);
	
	lpAppGuid=(LPGUID)&BOB_GUID;		

	if (res!=DP_OK)
		return FALSE;

	return TRUE;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		CountPlayers
//Date			Wed 10 Dec 1997
//------------------------------------------------------------------------------
void	DPlay::CountPlayers(bool joining)
{
	CurrPlayers=0;

	for (ULong n=0;n<MAXPLAYERS;n++)
	{
		if (joining)
		{
			if (H2H_Player[n].status==CPS_3D)
				CurrPlayers++;
		}
		else
		{
			if (H2H_Player[n].status!=CPS_NONE)
				CurrPlayers++;
		}
	}

	if (joining)
		CurrPlayers++; // want to include me!!!!!!
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		EnumConnectionsCallback
//Date			Wed 26 Nov 1997
//Description	Gets list of service providers and put them
//				into ServiceList
//------------------------------------------------------------------------------
BOOL WINAPI	EnumConnectionsCallback(LPCGUID lpguidSP,
									LPVOID lpConnection,
									DWORD dwConnectionSize,
									LPCDPNAME lpName,
									DWORD dwFlags,
									LPVOID pContext)
{
	ULong namelen;
	LPENUMSERVICE temp=_DPlay.ServiceList;

	if (lpguidSP)
	{
		if (_DPlay.ValidService(lpName->lpszShortNameA))
		{
			LPENUMSERVICE nextservice=new ENUMSERVICE;

			nextservice->Next=NULL;

			nextservice->sid=*lpguidSP;

			namelen=strlen(lpName->lpszShortNameA);
			nextservice->sname=new char[namelen+1];

			strcpy(nextservice->sname,lpName->lpszShortNameA);

			nextservice->connsize=dwConnectionSize;
			nextservice->connection=new UByte[dwConnectionSize];

			CopyMemory(nextservice->connection,lpConnection,dwConnectionSize);

			if (_DPlay.ServiceList==NULL)
			{
				_DPlay.ServiceList=nextservice;
			}
			else
			{
				while (temp->Next)
					temp=temp->Next;

				temp->Next=nextservice;
			}

			nextservice=NULL;
		}
	}

	return TRUE;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		EnumSessionsCallback
//Date			Wed 26 Nov 1997
//Description	Get list of session names for player to choose from
//------------------------------------------------------------------------------
BOOL WINAPI EnumSessionsCallback(LPCDPSESSIONDESC2 lpSessionDesc,
								LPDWORD lpdwTimeOut,
								DWORD dwFlags,
								LPVOID lpContext)
{
	ULong namelen;
	LPENUMSESSION temp=_DPlay.SessionList;

	if (lpSessionDesc)
	{
		LPENUMSESSION newsess=new ENUMSESSION;

		newsess->Next=NULL;
		namelen=strlen(lpSessionDesc->lpszSessionNameA);
		newsess->sname=new char[namelen+1];

		strcpy(newsess->sname,lpSessionDesc->lpszSessionNameA);

		if (_DPlay.SessionList==NULL)
		{
			_DPlay.SessionList=newsess;
		}
		else
		{
			while (temp->Next)
				temp=temp->Next;

			temp->Next=newsess;
		}

		newsess=NULL;

		return TRUE;
	}
	return FALSE;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		EnumSessionsDataCallback
//Date			Wed 26 Nov 1997
//Description	Get data of session chosen by player and copy into dpsessiondesc2
//------------------------------------------------------------------------------
BOOL WINAPI EnumSessionsDataCallback(LPCDPSESSIONDESC2 lpSessionDesc,
								LPDWORD lpdwTimeOut,
								DWORD dwFlags,
								LPVOID lpContext)
{
	if (lpSessionDesc)
	{
		if (!strcmp((char*)lpContext, lpSessionDesc->lpszSessionNameA))
		{
			_DPlay.tempdpsessdesc2=new char[sizeof(DPSESSIONDESC2)];
			CopyMemory(_DPlay.tempdpsessdesc2,lpSessionDesc,sizeof(DPSESSIONDESC2));

			return FALSE;
		}
		return TRUE;
	}
	return FALSE;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		ProcessSystemMessage
//Date			Wed 10 Dec 1997
//------------------------------------------------------------------------------
Bool	DPlay::ProcessSystemMessage(char* message)
{
	LPDPMSG_GENERIC Mess,Mess2;
	ULong n;
	
	Mess=(LPDPMSG_GENERIC)message;

	switch (Mess->dwType)
	{
		case DPSYS_ADDGROUPTOGROUP:
			LPDPMSG_ADDGROUPTOGROUP Mess2;

			Mess2=(LPDPMSG_ADDGROUPTOGROUP)message;
			break;

		case DPSYS_ADDPLAYERTOGROUP:
			LPDPMSG_ADDPLAYERTOGROUP Mess3;

			Mess3=(LPDPMSG_ADDPLAYERTOGROUP)message;

			lpDP4->AddPlayerToGroup(Mess3->dpIdGroup,Mess3->dpIdPlayer);
			break;

		case DPSYS_CHAT:
			LPDPMSG_CHAT Mess4;

			Mess4=(LPDPMSG_CHAT)message;
			break;

		case DPSYS_CREATEPLAYERORGROUP:
			LPDPMSG_CREATEPLAYERORGROUP Mess5;

			Mess5=(LPDPMSG_CREATEPLAYERORGROUP)message;
			break;

		case DPSYS_DELETEGROUPFROMGROUP:
			LPDPMSG_DELETEGROUPFROMGROUP Mess6;

			Mess6=(LPDPMSG_DELETEGROUPFROMGROUP)message;
			break;

		case DPSYS_DELETEPLAYERFROMGROUP:
			LPDPMSG_DELETEPLAYERFROMGROUP Mess7;

			Mess7=(LPDPMSG_DELETEPLAYERFROMGROUP)message;

			lpDP4->DeletePlayerFromGroup(Mess7->dpIdGroup,Mess7->dpIdPlayer);

			break;

		case DPSYS_DESTROYPLAYERORGROUP:
			LPDPMSG_DESTROYPLAYERORGROUP Mess8;

			Mess8=(LPDPMSG_DESTROYPLAYERORGROUP)message;

			if (Mess8->dwPlayerType==DPPLAYERTYPE_PLAYER)
			{
				n=DPID2Slot(Mess8->dpId);

				if (n==MAXPLAYERS)
					break;

// remove player from 3D if in 3D, and then from game

				bool	wasin3d=false;
				ULong	slot=DPID2Slot(Mess8->dpId);

				if (slot<MAXPLAYERS)
				{
					if (H2H_Player[slot].status==CPS_3D)
						wasin3d=true;
				}
				
				ProcessPlayerGone(Mess8->dpId,TRUE); 
				ProcessPlayerGone(Mess8->dpId,FALSE); 

				if (H2H_Player[mySlot].status==CPS_READYROOM)
					DisplayInfo=TRUE;

				if (Mess8->dpId==H2H_Player[0].dpid)
				{
// host has gone - lets go as well

					SimulateExitKey=TRUE;
					LeaveCommsFlag=TRUE;
					HostQuitFlag=TRUE;
				}
				else if (Host && ResyncPhase && wasin3d)
				{
// if player has left game whilst in sync phase then host restarts sync

					Initiator=TRUE;
					BeginSyncPhase();
				}
			}
			break;

		case DPSYS_HOST:
			LPDPMSG_HOST Mess9;

			Mess9=(LPDPMSG_HOST)message;

			LeaveCommsFlag=TRUE;
			HostQuitFlag=TRUE;

			break;

		case DPSYS_SECUREMESSAGE:
			LPDPMSG_SECUREMESSAGE Mess10;

			Mess10=(LPDPMSG_SECUREMESSAGE)message;
			break;

		case DPSYS_SESSIONLOST:
			LPDPMSG_SESSIONLOST Mess11;

			Mess11=(LPDPMSG_SESSIONLOST)message;

			SimulateExitKey=TRUE;
			LeaveCommsFlag=TRUE;
			HostQuitFlag=TRUE;

			break;

		case DPSYS_SETPLAYERORGROUPDATA:
			LPDPMSG_SETPLAYERORGROUPDATA Mess12;

			Mess12=(LPDPMSG_SETPLAYERORGROUPDATA)message;
			break;

		case DPSYS_SETPLAYERORGROUPNAME:
			LPDPMSG_SETPLAYERORGROUPNAME Mess13;

			Mess13=(LPDPMSG_SETPLAYERORGROUPNAME)message;
			break;

		case DPSYS_SETSESSIONDESC:
			LPDPMSG_SETSESSIONDESC Mess14;

			Mess14=(LPDPMSG_SETSESSIONDESC)message;
			break;

		case DPSYS_STARTSESSION:
			LPDPMSG_STARTSESSION Mess15;

			Mess15=(LPDPMSG_STARTSESSION)message;
			break;

		case DPSYS_SENDCOMPLETE:
			LPDPMSG_SENDCOMPLETE Mess16;

			Mess16=(LPDPMSG_SENDCOMPLETE)message;

// dont care about complete sends, I dont care if messages are sent or not!!!!
// anyway these messages should not arrive as I turn them off.....
			break;

		case DPSYS_SETGROUPOWNER:
			LPDPMSG_SETGROUPOWNER Mess17;

			Mess17=(LPDPMSG_SETGROUPOWNER)message;

			break;

		default:
// some future version of direct play may use other messages so dont error
			break;
	}

	return TRUE;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		ProcessPlayerMessage
//Date			Wed 10 Dec 1997
//------------------------------------------------------------------------------
Bool	DPlay::ProcessPlayerMessage(char* message,ULong size,ULong from)
{
	Bool	retval=TRUE;

	LPGENERIC pack=(LPGENERIC)message;

	switch (pack->PacketID)
	{
	case PID_CSSTRUCINIT:
		Process_PM_CSStruc(message,true);
		break;

	case PID_CSSTRUCNEW:
		Process_PM_CSStruc(message,false);
		break;
			
	case PID_UNIQUEID:
		Process_PM_UniqueID(message,from);
		break;

	case PID_RANDOMLIST:
		{
			Process_PM_RandomList(message);
		}
		break;

	case PID_RANDREQUEST:
		Process_PM_RandRequest();
		break;

	case PID_SINGLEPILOTSTATUS:
		ProcessPilotStatusPacket(true,(UByteP)message,size);
		break;

	case PID_ALLPILOTSSTATUS:
		ProcessPilotStatusPacket(false,(UByteP)message,size);
		break;

	case PID_RESTARTWORLDSYNC:
		RestartWorldSync=true;
		break;

	case PID_PLAYERUPDATE:
		Process_PM_PlayerUpdate(message);
		break;

	case PID_IMHERE:
		Process_PM_ImHere(message,from);
		break;

	case PID_IDREQUEST:
		ProcessIDRequest();
		break;

	case PID_PLAYERQUIT:
		if (!Process_PM_PlayerQuit(from))
			retval=FALSE;
		break;

	case PID_MESSAGE:
#ifndef	BOB_DEMO_VER
		Process_PM_Message(message);
#endif #ifndef	BOB_DEMO_VER
		break;

	case PID_DATAREQUEST:
		Process_PM_DataRequest(from);
		break;

	case PID_STATUSCHANGE:
		Process_PM_ScreenChange(pack->PlayerID,from);
		break;

	case PID_PREFSDATA:
		Process_PM_PrefsData(message);
		break;

	case PID_FLYNOW:
		if (!Process_PM_FlyNow())
			retval=FALSE;
		break;

	case PID_IAMIN:
		Process_PM_IAmIn(message,from);
		break;

	case PID_PASSWORD:
		Process_PM_Password(message,from);
		break;

	case PID_VISITORUPDATE:
		Process_PM_VisitorUpdate(message);
		break;

	case PID_NEEDRESYNC:
		if (!Process_PM_NeedResync())
			retval=FALSE;
		break;

	case PID_PREFSREQUEST:
		Process_PM_PrefsRequest(from);
		break;

	case PID_BFIELDREQUEST:
		Process_PM_BfieldsRequest();
		break;

	case PID_SLOTREQUEST:
		ProcessPlayerSlotRequest(message,from);
		break;

	case PID_SLOTINFOUPDATE:
		ProcessSlotInfoUpdate(message);
		break;

	case PID_GAMEDETAILSREQUEST:
		SendGameDetails(from);
		break;

	case PID_PLAYERINFOREQUEST:
		SendMyPlayerInfo(true);
		break;

	case PID_CSQUICKREQUEST:
		Process_PM_CSQuickRequest(from);
		break;

	case PID_MISSCONDSREQUEST:
		SendMissionConditions(true);
		break;

	case PID_MESSAGES:
		ReceiveMessages(message,from);
		break;

	case PID_MESSAGESREQUEST:
		SendMyMessages(true);
		break;

	case PID_SAVEGAME:
		Process_PM_SaveGame(message);
		break;

	case PID_RESYNC:
		Process_PM_Resync(message,from);
		break;

	case PID_READYWORLD:
		SyncData.wsrgot+=1<<DPID2Slot(from);
		break;

	case PID_HOSTLEAVING:
		SimulateExitKey=TRUE;
		break;

	case PID_GUESTLEAVING:
		ProcessGuestLeavingMessage(from);
		break;

	case PID_GAMEDETAILSINFO:
	case PID_PASSWORDVALID:
 	case PID_ITEMDATA:
 	case PID_NUMACANIMS:
 	case PID_NUMMOBANIMS:
 	case PID_NUMITEMANIMS:
 	case PID_ITEMANIM:
	case PID_BFIELDPACKETIDENT:
// dont int3 because if a 3rd player joins then player 2 may hit this int3
// even though it is not a problem
	case PID_SAVEGAMEBINARY:
	case PID_CAMPAIGNSTRUC:
	case PID_CAMPAIGNSTRUCBINARY:
	case PID_MISSIONCONDITIONS:
	case PID_CSSTRUCBINARY:
		break;

	case PID_HOSTLETSGO:
	case PID_PLAYERLETSGO:
		INT3;
		break;

	default:
		break;
	}

	return retval;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		SendFlyNow
//Date			Mon 15 Dec 1997
//------------------------------------------------------------------------------
Bool	DPlay::UISendFlyNow()
{
	UIPLAYERDATA UIPlayerData;

	UIPlayerData.PlayerID = myDPlayID;
	UIPlayerData.Slot = mySlot;
	UIPlayerData.PacketID = PID_FLYNOW;
	
	if (!SendMessageToGroup((char*)&UIPlayerData,sizeof(UIPLAYERDATA)))
	{
		return FALSE;
	}
	return TRUE;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		InitMainSheetInfo
//Date			Thu 18 Dec 1997
//------------------------------------------------------------------------------
void	DPlay::InitMainSheetInfo()
{
	UIPLAYERDATA UIPlayerData;

	if (MainSheetCount==2)
	{
// Signal this player is not in 3D
// on entry to game this is not needed because the data is already sent in the
// PID_IMHERE packet, however we still need this for when players come from 3d 
// to ready room

		(H2H_Player + mySlot)->status = CPS_READYROOM; // ready

// Send PID_NEWPLAYER

		CopyMemory((char*)(&UIPlayerData.playerinfo),(char*)(H2H_Player+mySlot),sizeof(H2HPlayerInfo));

		UIPlayerData.PlayerID = myDPlayID;
		UIPlayerData.Slot=mySlot;

		UIPlayerData.PacketID = PID_PLAYERUPDATE;

		SendMessageToGroup((char*)&UIPlayerData,sizeof(UIPLAYERDATA));
	}

// Send DATA REQUEST for other players

	UIPlayerData.PlayerID = myDPlayID;
	UIPlayerData.Slot=mySlot;
	UIPlayerData.PacketID = PID_DATAREQUEST;

	SendMessageToGroup((char*)&UIPlayerData,sizeof(UIPLAYERDATA));

	DisplayInfo=TRUE;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		StartCommsSession
//Date			Thu 11 Jun 1998
//------------------------------------------------------------------------------
Bool	DPlay::StartCommsSession()
{
	if (!UIMultiPlayInit())
		return FALSE;

	UIAssignServices();

	return TRUE;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		LaunchedByLobby
//Date			Fri 12 Jun 1998
//------------------------------------------------------------------------------
Bool	DPlay::LaunchedByLobbyCheck()
{
	HRESULT res;
	DWORD	size=0;

	CommsTimeoutLength=30000;
	RateDivider=3;

	res=CoCreateInstance(CLSID_DirectPlayLobby,NULL,CLSCTX_INPROC_SERVER,
		IID_IDirectPlayLobby3A,(LPVOID*)&lpDPL);

	if (res!=DP_OK)
	{
		ExitDirectPlay();
		return FALSE;
	}

	res=lpDPL->GetConnectionSettings(0,NULL,&size);

	if (res!=DP_OK && res!=DPERR_BUFFERTOOSMALL)
	{
		ExitDirectPlay();
		return FALSE;
	}

	templpDPC=(new char[size]);

	LPDPLCONNECTION lpDPC=(LPDPLCONNECTION)templpDPC;

	if (lpDPL->GetConnectionSettings(0,lpDPC,&size)!=DP_OK)
	{
		lpDPC=NULL;
		ExitDirectPlay();
		return FALSE;
	}

// set up session flags

	lpDPC->lpSessionDesc->dwFlags=DPSESSION_DIRECTPLAYPROTOCOL	// need asyncronous send
								|DPSESSION_KEEPALIVE			// keep track of player falling out
								| DPSESSION_OPTIMIZELATENCY; // no nagling

	lpDPC->lpSessionDesc->dwMaxPlayers=MAXPLAYERS+1;

	res=lpDPL->SetConnectionSettings(0,0,lpDPC);

	if (res!=DP_OK)
	{
		lpDPC=NULL;
		ExitDirectPlay();
		return FALSE;
	}

	lpDPC=NULL;
	PossibleLobby=true;

	_Replay.Record=FALSE;
	_Replay.Playback=FALSE;
	_Replay.BackupPrefs(true);										
	BackupHostPrefs();
 	Save_Data.gamedifficulty|=GD_VULNERABLE;
 	Save_Data.gamedifficulty|=GD_GROUNDCOLLISIONS;			
 	Save_Data.gamedifficulty|=GD_COLLISIONS;			
	Save_Data.flightdifficulty%=FD_ENGINEMANAGMENT;

	return TRUE;
}

Bool DPlay::ConnectToLobby()
{
	HRESULT res;

// if I am a guest then try to connect to the session
// host must wait until he has set up game options

	if (!PossibleLobby)
		return FALSE;

	LPDPLCONNECTION lpDPC=(LPDPLCONNECTION)templpDPC;

	if (!(lpDPC->dwFlags&DPLCONNECTION_CREATESESSION))
	{
		if (false)
		{
			if (lpDPL->ConnectEx(0,IID_IDirectPlay4A,(void**)&lpDP4,NULL)!=DP_OK)
			{
				lpDPC=NULL;
				ExitDirectPlay();
				return FALSE;
			}
		}
		else
		{
			res=DPERR_CONNECTING;

			res=lpDPL->ConnectEx(DPCONNECT_RETURNSTATUS,IID_IDirectPlay4A,(void**)&lpDP4,NULL);

			if (res!=DP_OK)
			{
				lpDPC=NULL;
				return FALSE;
			}
		}
	}

	lpDPC=NULL;
	return TRUE;
}

Bool DPlay::FinishLobbySetup()
{
	LPDPLCONNECTION lpDPC=(LPDPLCONNECTION)templpDPC;

	lpAppGuid=(LPGUID)&BOB_GUID;						

	if (lpDPC->dwFlags&DPLCONNECTION_CREATESESSION)
	{
		UIPlayerType=PLAYER_HOST;
		Host=TRUE;
	}
	else
	{
		UIPlayerType=PLAYER_GUEST;
		Host=FALSE;
	}

	if (lpDPC->lpPlayerName->lpszShortNameA)
	{
		strncpy (PlayerName,(char*)lpDPC->lpPlayerName->lpszShortNameA,59);
		PlayerName[59]=NULL;
	}
	else
	{
		strcpy(PlayerName,"Unnamed Player");
	}

	if (lpDPC->lpSessionDesc->lpszSessionNameA)
	{
		strncpy (SessionName,(char*)lpDPC->lpSessionDesc->lpszSessionName,59);
		SessionName[59]=NULL;
	}
	else
	{
		strcpy(SessionName,"Lobbied Game");
	}

	if (!Host)
	{
		if (!SetUpPlayer())
		{
			lpDPC=NULL;
			ExitDirectPlay();
			return FALSE;
		}

		if (UIPlayerType==PLAYER_GUEST)
		{
			if (!_DPlay.GetGameDetails())
			{
				lpDPC=NULL;
				CommsMessage(IDS_HOSTBUSY);
				ExitDirectPlay();
				return FALSE;
			}
		}
	}

	lpDPC=NULL;
	Lobbied=TRUE;

	return TRUE;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		SetUpPlayerInfo
//Date			Fri 12 Jun 1998
//------------------------------------------------------------------------------
Bool	DPlay::SetUpPlayerInfo(char* name)
{
// determine capabilities

	DPCAPS dpCaps;

	dpCaps.dwSize=sizeof(DPCAPS);

	if (lpDP4->GetCaps(&dpCaps,0)!=DP_OK)
		return FALSE;

	if (Host) 
	{
		mySlot=0;
	}

	if (lpDP4->AddPlayerToGroup(playergroupID,myDPlayID))
		return FALSE;

	InitH2HPArray();

// fill in name ,initial null dialogue, 0 kills and deaths 

	(H2H_Player+mySlot)->dpid=myDPlayID;

// if there is no name use a default

	if (!strcmp(name,""))
		strcpy ((H2H_Player + mySlot)->name, "Unnamed Player");
	else
		strcpy ((H2H_Player + mySlot)->name, name);

	(H2H_Player + mySlot)->status = CPS_READYROOM;
	strcpy ((H2H_Player + mySlot)->dialogue, "");

	if (_DPlay.GameType!=DEATHMATCH)
	{
		if (Side)
			(H2H_Player+mySlot)->MyTeam=TS_BLUE;
		else
			(H2H_Player+mySlot)->MyTeam=TS_RED;
	}
	else
	{
		(H2H_Player+mySlot)->MyTeam=TS_NONE;
	}

	FlyNowFlag = FALSE;

	sendtowho=0; // initially chat to everybody

// need to set up default AC for deathmatch/teamplay

	if (GameType==DEATHMATCH)
	{
		H2H_Player[mySlot].squadron=0;
	}
	else if (GameType==TEAMPLAY)
	{
		if (Side)
		{
			H2H_Player[mySlot].squadron=0;
		}
		else
		{
			H2H_Player[mySlot].squadron=PT_GER_FLYABLE;
		}
	}

	if (!Host)
	{
		SendImHereMessage();
	}

	ChatBuffer.InitBuffer();

	MainSheetCount=1;

	return TRUE;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		AddNameToVisitorsBook
//Date			Fri 12 Jun 1998
//Description	Only Host can add and remove name from the visitors book.
//				All other players must use SendUpdateToVisitorsBook to
//				alter it.
//------------------------------------------------------------------------------
void	DPlay::AddNameToVisitorsBook(char* name)
{
	if (Host && Password[0])
	{
		if (VisitorsBook)
		{
			LPVISITORINFO temp=VisitorsBook;

			while (temp)
			{
				if (!strcmp(temp->vis_name,name))
					return;

				temp=temp->next;
			}

			temp=VisitorsBook;

			while (temp->next)
			{
				temp=temp->next;
			}

			LPVISITORINFO a=new VISITORINFO;

			a->vis_status=FALSE;
			a->vis_name=new char[strlen(name)+1];
			strcpy(a->vis_name,name);
			a->next=NULL;
			temp->next=a;
			a=NULL;

			char temptext[256];
			strcpy(&temptext[0],name);
			strcat(&temptext[0]," has added name to visitor book");

			DisplayChatDialogue("VISITOR",&temptext[0]);
		}
		else
		{
			VisitorsBook=new VISITORINFO;

			VisitorsBook->vis_name=new char[strlen(name)+1];

			strcpy(VisitorsBook->vis_name,name);
			VisitorsBook->vis_status=FALSE;
			VisitorsBook->next=NULL;

			char temptext[256];
			strcpy(&temptext[0],name);
			strcat(&temptext[0]," has added name to visitor book");

			DisplayChatDialogue("VISITOR",&temptext[0]);
		}
	}
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		RemoveNameFromVisitorsBook
//Date			Fri 12 Jun 1998
//------------------------------------------------------------------------------
void	DPlay::RemoveNameFromVisitorsBook(char* name)
{
	if (Host)
	{
		if (VisitorsBook)
		{
			LPVISITORINFO a,b;

			a=b=VisitorsBook;

			a=a->next;

			if (!strcmp(b->vis_name,name))
			{
				b->next=NULL;
				delete [] b->vis_name;
				delete b;
				VisitorsBook=a;
			}
			else
			{
				while (a)
				{
					if (!strcmp(a->vis_name,name))
					{
						b->next=a->next;

						a->next=NULL;
						delete [] a->vis_name;
						delete a;
						
						break;
					}
					a=a->next;
					b=b->next;
				}
			}
		}
	}
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		ToggleVisitorStatus
//Date			Fri 12 Jun 1998
//------------------------------------------------------------------------------
void	DPlay::ToggleVisitorStatus(char* name)
{
	LPVISITORINFO a=VisitorsBook;

	while (a)
	{
		if (!strcmp(a->vis_name,name))
		{
			if (a->vis_status)
				a->vis_status=FALSE;
			else
				a->vis_status=TRUE;

			break;
		}

		a=a->next;
	}
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		SendUpdateToVisitorsBook
//Date			Mon 15 Jun 1998
//------------------------------------------------------------------------------
void	DPlay::SendUpdateToVisitorsBook(char* name,Bool status)
{
	INITINFO info;
	ULong	from=myDPlayID,to=DPID_ALLPLAYERS;
	HRESULT res;

	info.ID=status;
	strcpy(info.Name,name);
	info.PacketID=PID_VISITORUPDATE;

	res=lpDP4->Send(from,to,0,&info,sizeof(INITINFO));
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		DeleteLobbyInfo
//Date			Mon 6 Jul 1998
//------------------------------------------------------------------------------
void	DPlay::DeleteLobbyInfo()
{
	if (lpDPL)
		lpDPL->Release();
	lpDPL=NULL;

	if (templpDPC)
		delete [] templpDPC;
	templpDPC=NULL;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		DeleteVisitorBook
//Date			Mon 13 Jul 1998
//------------------------------------------------------------------------------
void	DPlay::DeleteVisitorBook()
{
	LPVISITORINFO a,b;

	a=VisitorsBook;

	while (a)
	{
		delete [] a->vis_name;
		b=a->next;
		delete a;
		a=b;
	}
	VisitorsBook=NULL;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		DeleteSessionList
//Date			Tue 14 Jul 1998
//------------------------------------------------------------------------------
void DPlay::DeleteSessionList()
{
	LPENUMSESSION temp1,temp2;
	temp1=SessionList;

	while (temp1)
	{
		delete[]temp1->sname;

		temp2=temp1->Next;
		temp1->Next=NULL;

		delete temp1;

		temp1=temp2;
	}
	SessionList=NULL;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		CheckPassword
//Date			Tue 28 Jul 1998
//Description	check if password is correct and send message
//------------------------------------------------------------------------------
void DPlay::CheckPassword(char* pword,char* name,ULong player)
{
	bool pwordOK=false;
	HRESULT res;
	GAMESTUFF pack;

	if (!strcmp(pword,&Password[0]))
		pwordOK=true;
	else
	{
// check in visitors book

		LPVISITORINFO	temp=_DPlay.VisitorsBook;

		while (temp)
		{
			if (!strcmp(temp->vis_name,name))
			{
// found player

				if (temp->vis_status)
					pwordOK=true;

				break;
			}
			temp=temp->next;
		}
	}

	pack.PacketID=PID_PASSWORDVALID;

	SLong nextslot=GetNextAvailableSlot();

	if (nextslot>=0)
	{
		pack.pwordOK=pwordOK;
		pack.newslot=nextslot;
		pack.groupID=playergroupID;
		pack.aggID=aggID;
	}
	else
	{
		pack.PlayerID=0;
	}

	SendMessageToPlayer((char*)&pack,sizeof(GAMESTUFF),player);
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		SetUpPlayer
//Date			Tue 28 Jul 1998
//------------------------------------------------------------------------------
Bool DPlay::SetUpPlayer()
{
	if(Host)
	{
// if I am the host then set up aggregator ID 
// create group and get ID

// aggregator gets its own thread - provide handle

		if (lpDP4->CreatePlayer ( &aggID, NULL, Master_3d.htable[Master_3d.EVENT_AGGREGATOR], NULL,0,0)!=DP_OK)
			return FALSE;

		if (lpDP4->CreateGroup( &playergroupID,NULL,NULL,0,0)!=DP_OK)
			return FALSE;
	}

	if (lpDP4->CreatePlayer ( &myDPlayID, NULL, NULL, NULL,0,0)!=DP_OK)
		return FALSE;

	PlayerCreated=TRUE;

	return TRUE;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		AttemptToJoin
//Date			Tue 28 Jul 1998
//------------------------------------------------------------------------------
ULong DPlay::AttemptToJoin()
{
 	HRESULT res;
	PASSWORDPACK pack;
	ULong from=myDPlayID,to=DPID_ALLPLAYERS;
	char* Buffer;
	ULong	Buflen;
	LPGAMESTUFF gs;
	Bool	result=FALSE;
	
	pack.PacketID=PID_PASSWORD;
	pack.PlayerID=myDPlayID;
	strncpy(&pack.pword[0],&Password[0],10);
	strcpy(&pack.name[0],&PlayerName[0]);


	res=lpDP4->Send(from,to,0,&pack,sizeof(PASSWORDPACK));

	if (res!=DP_OK)
		return FALSE;

	ULong now=timeGetTime();

	CommsTimeout time(now,CommsTimeoutLength);

	res=DPERR_INVALIDPARAM;

	while (!result)
	{
		now=timeGetTime();

		if (time.TimedOut(now))
			return FALSE;

		if (ReceiveNextMessageToMe(Buffer,Buflen,from,0))
		{
			if (from==0)
			{
// check to see if session has gone?

			}
			gs=(LPGAMESTUFF)Buffer;

			if (gs->PacketID==PID_PASSWORDVALID)
			{
// get all info
				if (gs->pwordOK)
				{
					mySlot=gs->newslot;
					playergroupID=gs->groupID;
					aggID=gs->aggID;
					result=TRUE;
					res=DP_OK;
				}
				else
				{
					break;
				}
			}
		}
	}

	return res;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		ReceiveNextMessageToMe
//Date			Fri 7 Aug 1998
//Description	General receive routine.
//				All messages must be handled. (including system messages)
//				No excuses allowed!
//------------------------------------------------------------------------------
Bool	DPlay::ReceiveNextMessageToMe(char*&data, ULong& len, ULong& from,ULong flags)
{
	HRESULT res;
	ULong To=myDPlayID;

	if (!PlayerCreated) 
		return FALSE;

// receive message to mydplayid in case I am aggregator. Dont want to receive packets 
// sent to aggregator here!!!!

	while (true)
	{
		res=lpDP4->Receive(&from, &To, flags, CommsPacketPtr, &CommsPacketLength);
		if (res==DPERR_BUFFERTOOSMALL)
		{
			delete [] CommsPacketPtr;
			CommsPacketPtr=NULL;
			CommsPacketPtr=new char[CommsPacketLength];
			if (!CommsPacketPtr)
				_Error.EmitSysErr("Out of memory");
		}
		else if (res==DP_OK)
		{
			data=CommsPacketPtr;
			len=CommsPacketLength;
			return TRUE;
		}
		else
			break;
	}

	return FALSE;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		SendGameDetails
//Date			Tue 13 Oct 1998
//------------------------------------------------------------------------------
void	DPlay::SendGameDetails(ULong from)
{
	GAMEDETAILS pack;
	GENERIC	cpack;

	if (Host)
	{
		pack.PacketID=PID_GAMEDETAILSINFO;
		pack.GameType=GameType;
		pack.GameIndex=GameIndex;
		pack.DataRate=RateDivider;

		SendMessageToPlayer((char*)&pack,sizeof(GAMEDETAILS),from);
	}
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		UpdatePlayerInfo
//Date			Wed 14 Oct 1998
//------------------------------------------------------------------------------
Bool	DPlay::UpdatePlayerInfo()
{
	char* RecPacket;
	ULong from;
	ULong RecPacketLen;

#ifdef CTRACE
	FILE* fp=fopen("ctrace.txt","at");
	fprintf(fp,"in UpdatePlayerInfo\n");
#endif

	if (!SendMyPlayerInfo (true))
	{
#ifdef CTRACE
		fprintf(fp,"Send failed\n\n");
		fclose(fp);
#endif
		return FALSE;
	}
#ifdef CTRACE
	fprintf(fp,"UpdatePlayerInfo TRUE\n\n");
	fclose(fp);
#endif
	return TRUE;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		SendMyPlayerInfo
//Date			Wed 14 Oct 1998
//------------------------------------------------------------------------------
bool	DPlay::SendMyPlayerInfo(bool request)
{
	UIPLAYERDATA pack;

	pack.PacketID=PID_PLAYERUPDATE;
	pack.Slot=mySlot; 

	CopyMemory((char*)&pack.playerinfo,(char*)&H2H_Player[mySlot],sizeof(H2HPlayerInfo));

	SendMessageToGroup((char*)&pack,sizeof(UIPLAYERDATA));

	return true;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		GetNextAvailableSlot
//Date			Thu 22 Oct 1998
//------------------------------------------------------------------------------
SLong	DPlay::GetNextAvailableSlot()
{
	ULong n;

	for (n=0;n<MAXPLAYERS;n++)
	{
		if (H2H_Player[n].status==CPS_NONE)
			return n;
	}

	return -1;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		ProcessPrefsPacket
//Date			Wed 28 Oct 1998
//------------------------------------------------------------------------------
void	DPlay::ProcessPrefsPacket(char* pack)
{
	PUIPREFSDATA pUIPrefsData;

	pUIPrefsData = (PUIPREFSDATA)pack;

// ignore Coordinated rudder, translucent smoke, priority messages, stick stiffness etc

	bool	autopadlock;

	autopadlock=Save_Data.gamedifficulty[GD_AUTOPADLOCKTOG];

	Save_Data.flightdifficulty	=	pUIPrefsData->flightdifficulty;
	Save_Data.gamedifficulty	=	pUIPrefsData->gamedifficulty;
	Save_Data.targetsize		=	pUIPrefsData->targetsize;
	Save_Data.autopilotskillLW	=	pUIPrefsData->autopilotskillLW;
	Save_Data.autopilotskillRAF	=	pUIPrefsData->autopilotskillRAF;

	if (pUIPrefsData->GEffects)
		Save_Data.hardwareconfig|=HW_GEFFECTS;
	else
		Save_Data.hardwareconfig%=HW_GEFFECTS;

	if (pUIPrefsData->InjuryEffects)
		Save_Data.hardwareconfig|=HW_INJURYEFFECTS;
	else
		Save_Data.hardwareconfig%=HW_INJURYEFFECTS;

	if (pUIPrefsData->WhiteOuts)
		Save_Data.hardwareconfig|=HW_WHITEOUT;
	else
		Save_Data.hardwareconfig%=HW_WHITEOUT;

	if (autopadlock)
		Save_Data.gamedifficulty|=GD_AUTOPADLOCKTOG;
	else
		Save_Data.gamedifficulty%=GD_AUTOPADLOCKTOG;

	if (pUIPrefsData->ACNames)
		Save_Data.detail_3d|=DETAIL3D_PADLOCKCHEAT;
	else
		Save_Data.detail_3d%=DETAIL3D_PADLOCKCHEAT;

	if (pUIPrefsData->Clouds)
		Save_Data.hardwareconfig|=HW_FLUFFYCLOUDS;
	else
		Save_Data.hardwareconfig%=HW_FLUFFYCLOUDS;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		AllPlayersHaveSlots
//Date			Tue 3 Nov 1998
//------------------------------------------------------------------------------
Bool	DPlay::AllPlayersHaveSlots()
{
	UByte num=0,n;

	for (n=0;n<MAXPLAYERS;n++)
	{
		if (H2H_Player[n].position!=-1 && H2H_Player[n].squadron!=-1)
		{
			num++;
		}
	}

	if (num==CurrPlayers)
		return TRUE;

	return FALSE;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		SendCS
//Date			Sun 8 Nov 1998
//------------------------------------------------------------------------------
void	DPlay::SendCS(UByte* info,ULong size, Bool init)
{
	GENERIC g;
	ULong n;

	if (!init)
	{
// need to unassign all players as mission has changed

		for (n=0;n<MAXPLAYERS;n++)
		{
			H2H_Player[n].squadron=-1;
			H2H_Player[n].position=-1;
		}

		MMC.playersquadron=-1;
		MMC.playeracnum=-1;
	}

#ifndef NDEBUG
// check to make sure that info will fit into packet
	if (size>CSSIZE)
		INT3;
#endif

	ULong numpackets=size/500;

	if (size%500)
		numpackets++;

	g.PlayerID=numpackets;
	g.Slot=size;

	if (init)
	{
		g.PacketID=PID_CSSTRUCINIT;
		SendMessageToPlayer((char*)&g, sizeof(GENERIC),0);
	}
	else
	{
		g.PacketID=PID_CSSTRUCNEW;
		SendMessageToGroup((char*)&g, sizeof(GENERIC));
	}

	ULong	index=0;
	ULong	copysize;
	CSSTRUCPART csp;
	UByteP ptr=info;

	while (numpackets--)
	{
		csp.PacketID=PID_CSSTRUCBINARY;
		csp.index=index++;

		if (numpackets)
			copysize=500;
		else
			copysize=size%500;

		csp.size=copysize;
		csp.newmissionnum=GameIndex;

		CopyMemory(&csp.data,ptr,copysize);
		ptr+=copysize;

		if (init)
		{
			SendMessageToPlayer((char*)&csp,sizeof(CSSTRUCPART),0);
		}
		else
		{
			SendMessageToGroup((char*)&csp,sizeof(CSSTRUCPART));
		}
	}
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		GetCS
//Date			Sun 8 Nov 1998
//------------------------------------------------------------------------------
Bool	DPlay::GetCS()
{
	char* Buffer;
	ULong	BufferLen=0;
	Bool	Got=FALSE;
	ULong From;
	ULong size,numparts;

	ULong now=timeGetTime();
	CommsTimeout time(now,CommsTimeoutLength);

	while(!Got)
	{
		now=timeGetTime();

		if (time.TimedOut(now))
			return FALSE;
		
		if (ReceiveNextMessageToMe(Buffer,BufferLen,From,0))
		{
			if (From==DPID_SYSMSG)
			{
				ProcessSystemMessage(Buffer);
			}
			else if (BufferLen!=sizeof(AGGSENDPACKET))
			{
				if (((LPGENERIC)Buffer)->PacketID == PID_CSSTRUCINIT)
				{
					size=((LPGENERIC)Buffer)->Slot;
					numparts=((LPGENERIC)Buffer)->PlayerID;
					Got=TRUE;
				}
			}
		}
	}

// get parts

	ULong rec=0;
	UByte*	struc=new UByte[size];

	time.Init(now,(CommsTimeoutLength*2));

	while (rec!=numparts)
	{
		now=timeGetTime();

		if (time.TimedOut(now))
		{
			delete [] struc;
			return FALSE;
		}

		if (ReceiveNextMessageToMe (Buffer, BufferLen,From,DPRECEIVE_TOPLAYER))
		{
// if we are getting info about game initally dont bother with any other messages

			if (From!=0 && BufferLen!=sizeof(AGGSENDPACKET))
			{
				if(((LPGENERIC)Buffer)->PacketID == PID_CSSTRUCBINARY)
				{
					LPCSSTRUCPART csp=(LPCSSTRUCPART)Buffer;

					GameIndex=csp->newmissionnum;

					UByteP temp=struc;

					temp+=(csp->index)*500;

					CopyMemory(temp,csp->data,csp->size);

					rec++;
				}
			}
		}
	}

	UpdateCSQuick((UByte*)struc,GameIndex);

	delete [] struc;
	return TRUE;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		SendCSRequest
//Date			Sun 8 Nov 1998
//------------------------------------------------------------------------------
void	DPlay::SendCSRequest()
{
	GENERIC p;
	p.PacketID=PID_CSQUICKREQUEST;
	ULong retries=10;

	while(!SendRequestMessage((char*)&p,sizeof(GENERIC)))
	{
		ULong end=timeGetTime()+100; // 10th sec

		while (timeGetTime()<end)
		{
			Sleep(0);
		}
		retries--;

		if (!retries)
			break;
	}
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		SendMyMessages
//Date			Wed 11 Nov 1998
//------------------------------------------------------------------------------
bool	DPlay::SendMyMessages(bool request)
{
	MESSAGEPACKET p;
	ULong n;

	p.PacketID=PID_MESSAGES;

	for (n=0;n<NUMRADIOMESSAGES;n++)
	{
		strcpy (p.messages[n],Messages[mySlot][n]);
	}

	return (SendMessageToGroup((char*)&p,sizeof(MESSAGEPACKET)));
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		ReceiveMessages
//Date			Wed 11 Nov 1998
//------------------------------------------------------------------------------
void	DPlay::ReceiveMessages(char* p,ULong from)
{
	ULong n,slot=DPID2Slot(from);
	LPMESSAGEPACKET m=(LPMESSAGEPACKET)p;

	if (slot!=MAXPLAYERS)
	{
		for (n=0;n<NUMRADIOMESSAGES;n++)
		{
			strcpy(Messages[slot][n],m->messages[n]);
		}
	}
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		SelectPlayerToChatTo
//Date			Tue 1 Dec 1998
//------------------------------------------------------------------------------
void	DPlay::SelectPlayerToChatTo(ULong playerslot)
{
	SLong slot=-1;

	if (_DPlay.GameType==DEATHMATCH)
	{
		slot=playerslot;
	}
	else
	{
		ULong count=0,n;

		for (n=0;n<MAXPLAYERS;n++)
		{
			if ((H2H_Player+n)->MyTeam==TS_BLUE || (H2H_Player+n)->MyTeam==TS_NONE)
			{
				if (count==playerslot)
				{
					slot=n;
					break;
				}
						  	
				count++;
			}
		}

		if (n==MAXPLAYERS)
		{
			for (n=0;n<MAXPLAYERS;n++)
			{
				if ((H2H_Player+n)->MyTeam==TS_RED)
				{
					if (count==playerslot)
					{
						slot=n;
						break;
					}
					count++;
				}
			}
		}
	}

	if (slot!=-1)
		sendtowho=H2H_Player[slot].dpid;
}

void	DPlay::ResetAllocPacket()
{
	ULong n;

	for (n=0;n<MAXPLAYERS;n++)
	{
		AllocPacket[n]=0;
	}
}

void	DPlay::ResetCommsGame()
{
	ULong n;

	SimulateExitKey=FALSE;

// unassign all players

	if (GameType>TEAMPLAY)
	{
		for(n=0;n<MAXPLAYERS;n++)
		{
			H2H_Player[n].squadron=-1;
			H2H_Player[n].position=-1;
		}
		MMC.playersquadron=-1;
	}
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		UpdateMessages
//Date			Wed 9 Dec 1998
//------------------------------------------------------------------------------
bool	DPlay::UpdateMessages()
{
	char* RecPacket;
	ULong from;
	ULong RecPacketLen;

#ifdef CTRACE
	FILE* fp=fopen("ctrace.txt","at");
	fprintf(fp,"In UpdateMessages\n");
#endif

	if (!SendMyMessages(false))
	{
#ifdef CTRACE
		fprintf(fp,"Failed to send\n\n");
		fclose(fp);
#endif
		return false;
	}
#ifdef CTRACE
	fprintf(fp,"UpdateMessages TRUE\n\n");
	fclose(fp);
#endif

	return TRUE;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		UpdateMissionConditions
//Date			Tue 5 Jan 1999
//------------------------------------------------------------------------------
Bool	DPlay::UpdateMissionConditions()
{
	ULong RecPacketLen;
	ULong from;
	char* RecPacket;

	if (Host)
	{
		if (!SendMissionConditions (false))
			return FALSE;
	}
	else
	{
// Receive Prefs Packet

		ULong now=timeGetTime();

		CommsTimeout time(now,CommsTimeoutLength);

		for (;;)
		{
			now=timeGetTime();

			if (time.TimedOut(now))
				_Error.SayAndQuit("Timed out (UMC)");

			if (ReceiveNextMessageToMe(RecPacket, RecPacketLen,from,DPRECEIVE_TOPLAYER))
			{
				if (from==DPID_SYSMSG)
				{
					ProcessSystemMessage(RecPacket);
				}
				else if (from!=aggID)
				{
					PUIPLAYERDATA pUIPlayerData = (PUIPLAYERDATA)RecPacket;

					if (pUIPlayerData->PacketID == PID_MISSIONCONDITIONS)
				   	{
						ProcessConditionsPacket(RecPacket);
						break;

					}
					else
					{
						ProcessPlayerMessage(RecPacket,RecPacketLen,from);
					}
				}
			}
		}
	}
	return TRUE;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		SendMissionConditions
//Date			Tue 5 Jan 1999
//------------------------------------------------------------------------------
Bool	DPlay::SendMissionConditions(bool request)
{
	CONDITIONSDATA 	cd;
	MISSIONCONDS	mc;
	int i;

	if (PlayerCreated && Host)
	{
		cd.PacketID=PID_MISSIONCONDITIONS;

		mc.TempVar=MMC.Sky.TempVar;
		mc.Temp0=MMC.Sky.Temp0;
		mc.Press0=MMC.Sky.Press0;
		mc.Density0=MMC.Sky.Density0;
		mc.wind0=MMC.Sky.wind0;
		mc.dir0=MMC.Sky.dir0;				
		mc.windalt=MMC.Sky.windalt;			
		mc.diralt=MMC.Sky.diralt;				
		mc.Wind0=MMC.Sky.Wind0;				
		mc.WindAlt=MMC.Sky.WindAlt;			
		mc.WindAltHeight=MMC.Sky.WindAltHeight;		
		mc.MinDuration=MMC.Sky.MinDuration;		
		mc.MaxDuration=MMC.Sky.MaxDuration;		
		mc.MinMagnitude=MMC.Sky.MinMagnitude;		
		mc.MaxMagnitude=MMC.Sky.MaxMagnitude;		
		mc.Frequency=MMC.Sky.Frequency;		
		mc.ContrailBandCentre=MMC.Sky.ContrailBandCentre;
		mc.ContrailBandWidth=MMC.Sky.ContrailBandWidth;
		mc.Visibility=MMC.Sky.Visibility;			
		mc.Conditions=MMC.Sky.Conditions;			
		mc.CloudLayer=MMC.Sky.CloudLayer;

		for (i=0;i<3;i++)
		{
			mc.Layer[i].AltBase=MMC.Sky.Layer[i].AltBase;
			mc.Layer[i].AltTop=MMC.Sky.Layer[i].AltTop;
			mc.Layer[i].Cover=MMC.Sky.Layer[i].Cover;
		}

		mc.FluffyCloud.AltBase=MMC.Sky.FluffyCloud.AltBase;
		mc.FluffyCloud.AltTop=MMC.Sky.FluffyCloud.AltTop;
		mc.FluffyCloud.Cover=MMC.Sky.FluffyCloud.Cover;

		mc.MistInValley=MMC.Sky.MistInValley;

		if (sizeof(MISSIONCONDS)>CONDSSIZE)
			_Error.SayAndQuit("Mission Conditions>CONDSZIE (%d)",sizeof(MISSIONCONDS));

		CopyMemory(&cd.conds,&mc,sizeof(MISSIONCONDS));

		if (request)
		{
			if (SendRequestMessage((char*)&cd, sizeof(CONDITIONSDATA)))
				return TRUE;
		}
		else
		{
			if (SendMessageToGroup((char*)&cd, sizeof(CONDITIONSDATA)))
				return TRUE;
		}
	}

	return FALSE;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		ProcessConditionsPacket
//Date			Tue 5 Jan 1999
//------------------------------------------------------------------------------
void	DPlay::ProcessConditionsPacket(char* message)
{
	LPCONDITIONSDATA 	cd;
	LPMISSIONCONDS	mc;
	int i;

	cd=(LPCONDITIONSDATA)message;
	mc=(LPMISSIONCONDS)cd->conds;

	MMC.Sky.TempVar=mc->TempVar;
	MMC.Sky.Temp0=mc->Temp0;
	MMC.Sky.Press0=mc->Press0;
	MMC.Sky.Density0=mc->Density0;
	MMC.Sky.wind0=mc->wind0;
	MMC.Sky.dir0=mc->dir0;
	MMC.Sky.windalt=mc->windalt;
	MMC.Sky.diralt=mc->diralt;
	MMC.Sky.Wind0=mc->Wind0;
	MMC.Sky.WindAlt=mc->WindAlt;
	MMC.Sky.WindAltHeight=mc->WindAltHeight;	
	MMC.Sky.MinDuration=mc->MinDuration;
	MMC.Sky.MaxDuration=mc->MaxDuration ;
	MMC.Sky.MinMagnitude=mc->MinMagnitude;
	MMC.Sky.MaxMagnitude=mc->MaxMagnitude;
	MMC.Sky.Frequency=mc->Frequency;
	MMC.Sky.ContrailBandCentre=mc->ContrailBandCentre;
	MMC.Sky.ContrailBandWidth=mc->ContrailBandWidth;
	MMC.Sky.Visibility=mc->Visibility;
	MMC.Sky.Conditions=mc->Conditions;
	MMC.Sky.CloudLayer=mc->CloudLayer;

	for (i=0;i<3;i++)
	{
		MMC.Sky.Layer[i].AltBase=mc->Layer[i].AltBase;
		MMC.Sky.Layer[i].AltTop=mc->Layer[i].AltTop;
		MMC.Sky.Layer[i].Cover=mc->Layer[i].Cover;
	}

	MMC.Sky.FluffyCloud.AltBase=mc->FluffyCloud.AltBase;
	MMC.Sky.FluffyCloud.AltTop=mc->FluffyCloud.AltTop;
	MMC.Sky.FluffyCloud.Cover=mc->FluffyCloud.Cover;

	MMC.Sky.MistInValley=mc->MistInValley;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		DisplayPlayerJoiningMessage
//Date			Mon 11 Jan 1999
//------------------------------------------------------------------------------
void	DPlay::DisplayPlayerJoiningMessage(ULong slot)
{
	AirStrucPtr ac=*Persons2::ConvertPtrUID((UniqueID)AllocPacket[slot]);

	DisplayPlayerMessage(ac,ac,ST_PLAYERJOINING,0);
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		SendSavegame
//Date			Thu 14 Jan 1999
//------------------------------------------------------------------------------
bool	DPlay::SendSaveGame(bool score,bool startup)
{
// copy savegame file into as many packets as needed. Send a header packet saying how
// many packets to expect, and inital segment of save data. Subsequent packets have
// header saying which packet they are in the order (in case of out of order arrivals)

	GENERIC cd;
	char savedgamename[150];
	ULong	savesize,numpackets;
	HANDLE	savegame;

	strcpy(savedgamename,"dcomms.dat");

	GetCommsSavename(savedgamename);

	if (H2H_Player[mySlot].status!=CPS_3D)
		_Replay.SaveTempSaveGame("dcomms.dat");

	savegame=CreateFile(
		savedgamename,
		GENERIC_READ,
		FILE_SHARE_READ,
		NULL,
		OPEN_EXISTING,
		NULL,
		NULL);

	if (savegame!=INVALID_HANDLE_VALUE)
	{
		savesize=GetFileSize(savegame,NULL);
		numpackets=savesize/500;
		if (savesize%500)
			numpackets++;

		cd.PacketID=PID_SAVEGAME;

		cd.PlayerID=numpackets;
		cd.Slot=savesize;

		if (startup)
		{
			if (!SendMessageToPlayer((char*)&cd, sizeof(GENERIC),0))
				return false;
		}
		else
		{
			if (!SendMessageToGroup((char*)&cd, sizeof(GENERIC)))
				return false;
		}

		ULong	index=0;
		SAVEGAMEPACKET sgp;
		ULong	readsize;
		ULong	numread;

		while (numpackets--)
		{
			sgp.PacketID=PID_SAVEGAMEBINARY;
			sgp.index=index++;

			if (numpackets)
				readsize=500;
			else
				readsize=savesize%500;

			sgp.size=readsize;

			ReadFile(
				savegame,
				&sgp.data,
				readsize,
				&numread,
				NULL);

			if (startup)
			{
				if (!SendMessageToPlayer((char*)&sgp,sizeof(SAVEGAMEPACKET),0))
					return false;
			}
			else
			{
				if (!SendMessageToGroup((char*)&sgp,sizeof(SAVEGAMEPACKET)))
					return false;
			}
		}
	}

	return true;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		ReceiveSavegame
//Date			Thu 14 Jan 1999
//------------------------------------------------------------------------------
bool	DPlay::ReceiveSaveGame(bool startup,ULong num,ULong size)
{
	char* RecPacket;
	ULong RecPacketLen=0,from;
	ULong now=timeGetTime();
	ULong rec=0;
	UByte*	save=new UByte[size];

	CommsTimeout time(now,(CommsTimeoutLength*2));

	while (rec!=num)
	{
		now=timeGetTime();

		if (time.TimedOut(now))
		{
			delete [] save;
			return false;
		}

		if (ReceiveNextMessageToMe (RecPacket, RecPacketLen,from,DPRECEIVE_TOPLAYER))
		{
			if (startup)
			{
// if we are getting info about game initally dont bother with any other messages

				if (from!=0 && RecPacketLen!=sizeof(AGGSENDPACKET))
				{
					if(((LPGENERIC)RecPacket)->PacketID == PID_SAVEGAMEBINARY)
					{
						rec++;
						UpdateSaveGame(save,RecPacket);
					}
				}
			}
			else
			{
				if (from==DPID_SYSMSG)
				{
					ProcessSystemMessage(RecPacket);
				}
				else if (from!=aggID)
				{
					if(((LPGENERIC)RecPacket)->PacketID == PID_SAVEGAMEBINARY)
					{
						rec++;
						UpdateSaveGame(save,RecPacket);
					}
					else
					{
						ProcessPlayerMessage(RecPacket,RecPacketLen,from);
					}
				}
			}
		}
	}

	bool retval=SaveDummyCommsSaveGame(save,size);

	if (retval)
	{
		retval=LoadDummySavegame("dcomms.dat");

		if (H2H_Player[mySlot].status==CPS_FRAG)	
			FragChanged=true;		
	}

	delete [] save;
	return retval;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		UpdateSaveGame
//Date			Mon 18 Jan 1999
//------------------------------------------------------------------------------
void	DPlay::UpdateSaveGame(UByte* savegamedata,char* pack)
{
	LPSAVEGAMEPACKET sgp;
	UByteP temp=savegamedata;

	sgp=(LPSAVEGAMEPACKET)pack;

	temp+=((sgp->index)*500);

	CopyMemory(temp,sgp->data,sgp->size);
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		SaveDummyCommsSaveGame
//Date			Mon 18 Jan 1999
//------------------------------------------------------------------------------
bool	DPlay::SaveDummyCommsSaveGame(UByte* data,ULong size)
{
	char	dummyname[150];
	HANDLE	dummyfile;
	ULong temp;
	bool	retval=false;

	strcpy(dummyname,"dcomms.dat");

	GetCommsSavename(dummyname);

	dummyfile=CreateFile(
		dummyname,
		GENERIC_WRITE,
		FILE_SHARE_WRITE,
		NULL,
		CREATE_ALWAYS,
		NULL,
		NULL);

	if (dummyfile!=INVALID_HANDLE_VALUE)
	{
		WriteFile(
			dummyfile,
			data,
			size,
			&temp,
			NULL);

		retval=true;
	}

	CloseHandle(dummyfile);

	return retval;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		JoinComms
//Date			Wed 20 Jan 1999
//------------------------------------------------------------------------------
Bool	DPlay::JoinComms()
{
	_DPlay.UIPlayerType = PLAYER_GUEST;

// need a temp name to be able to create a player with

	strcpy(_DPlay.PlayerName,"temp name");

// need to get game details before going to locker room so that info can be filled
// in correctly....

	if (_DPlay.UINewPlayer(_DPlay.PlayerName,_DPlay.SessionName))
	{
// null temp player name

		strcpy (_DPlay.PlayerName,"");

		if (_DPlay.GetGameDetails())
		{
			return TRUE;
		}
		CommsMessage(IDS_HOSTBUSY);
	}

	SessionName[0]='/0';					
	strcpy(_DPlay.PlayerName,"");

	_DPlay.lpDP4->DestroyPlayer(_DPlay.myDPlayID);
	_DPlay.lpDP4->Close();

	return FALSE;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		FindGoodSession
//Date			Wed 20 Jan 1999
//------------------------------------------------------------------------------
Bool	DPlay::FindGoodSession()
{
	ULong now=timeGetTime();
	CommsTimeout	time(now,CommsTimeoutLength);

	while (!time.TimedOut(timeGetTime()))
	{
		_DPlay.UIGetSessionListUpdate();

		if (_DPlay.SessionList)
		{
			strncpy(_DPlay.SessionName,_DPlay.SessionList->sname,59);
			_DPlay.SessionName[59]=NULL;

			return TRUE;
		}
	}

	return FALSE;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		SendCampaignStruc
//Date			Thu 13 May 1999
//------------------------------------------------------------------------------
bool	DPlay::SendCampaignStruc(bool startup)
{
	GENERIC cd;
	ULong numpackets;
	ULong campsize=sizeof(Campaign);

	numpackets=campsize/500;
	if (campsize%500)
		numpackets++;

	cd.PacketID=PID_CAMPAIGNSTRUC;
	cd.PlayerID=numpackets;

	if (startup)
		SendMessageToPlayer((char*)&cd,sizeof(GENERIC),0);
	else
		SendMessageToGroup((char*)&cd, sizeof(GENERIC));

	ULong	index=0;
	ULong	copysize;
	ULong	numread;
	SAVEGAMEPACKET sgp;
	UByteP temp=(UByteP)&MMC;

	while (numpackets--)
	{
		sgp.PacketID=PID_CAMPAIGNSTRUCBINARY;
		sgp.index=index++;

		if (numpackets)
			copysize=500;
		else
			copysize=campsize%500;

		sgp.size=copysize;

		CopyMemory(&sgp.data,temp,copysize);
		temp+=copysize;

		if (startup)
		{
			SendMessageToPlayer((char*)&sgp,sizeof(SAVEGAMEPACKET),0);
		}
		else
		{
			if (!SendMessageToGroup((char*)&sgp,sizeof(SAVEGAMEPACKET)))
				return false;
		}
	}

	return true;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		ReceiveCampaignStruc
//Date			Thu 13 May 1999
//------------------------------------------------------------------------------
bool	 DPlay::ReceiveCampaignStruc()
{
	char* buffer;
	ULong buflen=0,from;
	ULong now=timeGetTime();
	ULong rec=0,num;
	bool	got=false;

	CommsTimeout time(now,CommsTimeoutLength);

	while (!got)
	{
		now=timeGetTime();

		if (time.TimedOut(now))
			return false;

		if (ReceiveNextMessageToMe(buffer,buflen,from,DPRECEIVE_TOPLAYER))
		{
			if (from==DPID_SYSMSG)
			{
				ProcessSystemMessage(buffer);
			}
			else if (from!=aggID)
			{
				if (((LPGENERIC)buffer)->PacketID==PID_CAMPAIGNSTRUC)
				{
					got=true;
					num=((LPGENERIC)buffer)->PlayerID;
				}
				else
				{
				 	ProcessPlayerMessage(buffer,buflen,from);
				}
			}
		}
	}

	now=timeGetTime();
	time.Init(now,(CommsTimeoutLength*2));

	while (rec!=num)
	{
		now=timeGetTime();

		if (time.TimedOut(now))
			return false;

		if (ReceiveNextMessageToMe (buffer, buflen,from,DPRECEIVE_TOPLAYER))
		{
			if (from==DPID_SYSMSG)
			{
				ProcessSystemMessage(buffer);
			}
			else if (from!=aggID)
			{
				LPSAVEGAMEPACKET sgp=(LPSAVEGAMEPACKET)buffer;

				if (sgp->PacketID==PID_CAMPAIGNSTRUCBINARY)
				{
					rec++;
					UByteP temp=(UByteP)&MMC;

					temp+=(500*(sgp->index));

					CopyMemory(temp,sgp->data,sgp->size);
				}
				else
				{
				 	ProcessPlayerMessage(buffer,buflen,from);
				}
			}
		}
	}

	return true;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		InitialFlagReset
//Date			Sun 6 Jun 1999
//------------------------------------------------------------------------------
void	DPlay::InitialFlagReset()
{
// reset all flags etc before launching 3d as inital sync is on interrupt and can get
// called before flags are setup in SendInit and SendInit2 etc

	FirstResurrectFrame=true;
	resyncbar=true;
	joiningplayerslot=-1;
	SuicideTime=0;
	AllowSuicide=TRUE;
	GameRunning=TRUE;
	deadplayers=0;
	Implemented = TRUE;								
	firsttimein = TRUE; 
	synched=FALSE; 
	csync=false; 
	ResyncPhase=FALSE; 
	Initiator=FALSE; 
	realfirsttimein=TRUE; 
	resyncsgot=0; 
	SimulateExitKey=FALSE; 
	InitSyncData(true); 
	FrameCount = 0; 
	ResetSync=true; 
	resetreceivesync=false;
	resyncsgot=0;
	PlayerSync=false;
	resurrectend=false;

	BFieldToProcess=0;
	_Replay.DeleteFileAndGlobRefList(_Replay.bfgrlist);

	BufferSize=128;

	for (int n=0;n<MAXPLAYERS;n++)
		CommsKiller[n]=255;

	hitResurrect = false;

	Save_Data.flightdifficulty%=FD_WINDEFFECTS;
	Save_Data.flightdifficulty%=FD_WINDGUSTS;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		SendBackupRandomList
//Date			Fri 18 Jun 1999
//------------------------------------------------------------------------------
void	DPlay::SendBackupRandomList(bool request)
{
	ULong n,packsize=sizeof(ULong) //PID
					+(RNDPACKETSIZE*sizeof(UWord));

	UByteP pack=new UByte[packsize];
	UByteP temp=pack;

	*(ULong*)temp=PID_RANDOMLIST;
	temp+=sizeof(ULong);

	for (n=0;n<(RNDPACKETSIZE);n++)
	{
		*(UWord*)temp=_Replay.BackupRndPacket[n];
		temp+=sizeof(UWord);
	}

	SendMessageToGroup((char*)pack,packsize);

// OK process the list myself now so that all players are same

	Process_PM_RandomList((char*)pack);

	delete [] pack;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		ProcessRandomList
//Date			Fri 18 Jun 1999
//------------------------------------------------------------------------------
void	DPlay::Process_PM_RandomList(char* packet)
{
	UWord RndPacket [RNDPACKETSIZE];
	ULong n;

	packet+=sizeof(ULong); //skip PID

	for (n=0; n<RNDPACKETSIZE; n++)
	{
		RndPacket[n] = *(UWord*)packet;
		packet+=sizeof(UWord);
	}

	for (n=0; n<(RNDPACKETSIZE - 2); n++)
		Math_Lib.SetRndLookUp(n,RndPacket[n]);

	Math_Lib.Setbval(RndPacket[(RNDPACKETSIZE - 2)]);
	Math_Lib.Setcval(RndPacket[(RNDPACKETSIZE - 1)]);
}

void DPlay::Process_PM_RandRequest()
{
	if (Host)
	{
		if (CommsStage[STAGE_RANDOMLIST][0])
		{
			SendBackupRandomList(true);
		}
		else
		{
			CommsStage[STAGE_RANDOMLIST][1]=true;
		}
	}
}

void DPlay::Process_PM_PlayerUpdate(char* message)
{
	CopyMemory(&H2H_Player[((PUIPLAYERDATA)message)->Slot],&((PUIPLAYERDATA)message)->playerinfo,sizeof(H2HPlayerInfo));

// display data

	if (H2H_Player[mySlot].status==CPS_READYROOM)
		DisplayInfo=TRUE;
}

void DPlay::Process_PM_ImHere(char* message,ULong from)
{
	ULong n;
	PUIPLAYERDATA p=(PUIPLAYERDATA)message;

	CopyMemory(&H2H_Player[p->Slot],&(p->playerinfo),sizeof(H2HPlayerInfo));

	for (n=0;n<MAXPLAYERS;n++)
	{
		if (n==p->Slot)
		{
			H2H_Player[n].dpid=from;
			H2H_Player[n].status=CPS_READYROOM;

			break;
		}
	}
}

bool DPlay::Process_PM_PlayerQuit(ULong from)
{
	UByte senders_slot=DPID2Slot(from);

	if (senders_slot==0)
	{
// Host quit - chuck all players back to intro screen

		MyTeamKills=0;
		MyTeamDeaths=0;

		EnemyTeamKills=0;
		EnemyTeamDeaths=0;

		SimulateExitKey=TRUE; 
		LeaveCommsFlag=TRUE;

		return false;
	}
	else
	{
		ProcessPlayerGone(from,FALSE);

		if (H2H_Player[mySlot].status==CPS_READYROOM)
			DisplayInfo=TRUE;
		UpdateFrag=TRUE; // get rid of player from frag screen
	}

	return true;
}

void DPlay::Process_PM_Message(char* m)
{
	PUIPLAYERDATA pUIPlayerData=(PUIPLAYERDATA)m;

	if (pUIPlayerData->PlayerID==0
	|| (pUIPlayerData->PlayerID==1 && pUIPlayerData->playerinfo.MyTeam==H2H_Player[mySlot].MyTeam)
	|| (pUIPlayerData->PlayerID==H2H_Player[mySlot].dpid))
	{
		DisplayChatDialogue(pUIPlayerData->playerinfo.name,pUIPlayerData->playerinfo.dialogue);
		AddChatMessageToBuffer(pUIPlayerData->playerinfo.name,pUIPlayerData->playerinfo.dialogue);
	}
}

void DPlay::Process_PM_DataRequest(ULong from)
{
// this is called firsttime in to get players info
// Send PID_PLAYERUPDATE - copy info in packet h2hplayer

	SendMyPlayerInfo(true);

	if (Host)
	{
		UISendPrefs (from);
		if (GameType==COMMSQUICKMISSION)
		{
// send as an init packet so that players currently in do not get positions reset

			SendCSQuickStrucToPlayers(TRUE);
		}
	}
}

void DPlay::Process_PM_ScreenChange(ULong screen, ULong from)
{
	UByte senders_slot=DPID2Slot(from);

	if (senders_slot!=MAXPLAYERS)
	{
		H2H_Player[senders_slot].status=screen;
	 	DisplayInfo=TRUE;
	}
}

void DPlay::Process_PM_PrefsData(char* message)
{
	if (H2H_Player[mySlot].status!=CPS_3D)
	{
		ProcessPrefsPacket(message);
	}
}

bool DPlay::Process_PM_FlyNow()
{
	if (!Host
	&& 	((GameType<COMMSQUICKMISSION && H2H_Player[mySlot].status==CPS_READYROOM)
	|| (GameType==COMMSQUICKMISSION && H2H_Player[mySlot].status==CPS_FRAG)))
	{
		FlyNowFlag = TRUE;
		return FALSE;
	}
	return TRUE;
}

void DPlay::Process_PM_PlayerLeavingGame(ULong from)
{
	UByte slot=DPID2Slot(from);

	if (slot!=MAXPLAYERS)
		H2H_Player[slot].status=CPS_READYROOM;
}

void DPlay::Process_PM_IAmIn(char* message, ULong from)
{
	UByte senders_slot=DPID2Slot(from);

	if (H2H_Player[mySlot].status==CPS_3D)
	{
		ULong slot;
		LPGENERIC pack=(LPGENERIC)message;
		
		slot=DPID2Slot(from);
		H2H_Player[slot].status=CPS_3D;
		AddPlayerToGame(slot,pack->PlayerID,pack->Slot);
		DisplayPlayerJoiningMessage(senders_slot);
	}
	else
	{
		if (senders_slot!=-1)
			H2H_Player[senders_slot].status=CPS_3D;
	}
}

void DPlay::Process_PM_Password(char* message, ULong from)
{
	if (Host)
	{
		LPPASSWORDPACK ppack=(LPPASSWORDPACK)message;

		CheckPassword(ppack->pword,ppack->name,from);
	}
}

void DPlay::Process_PM_VisitorUpdate(char* message)
{
	if (Host)
	{
		PINITINFO ipack=(PINITINFO)message;
		AddNameToVisitorsBook(ipack->Name);
	}
}

bool DPlay::Process_PM_NeedResync()
{
	if (H2H_Player[mySlot].status==CPS_3D && !Joining)
	{
		if (!ResyncPhase)
		{ 
			BeginSyncPhase();
			return false;
		}
	}
	return true;
}

void DPlay::Process_PM_PrefsRequest(ULong from)
{
	if (Host)
	{
		if (!UISendPrefs(from))
			_Error.SayAndQuit("Error sending prefs");
	}
}

void DPlay::Process_PM_BfieldsRequest()
{
	if (Host)
	{
		if (CommsStage[STAGE_BFIELDS][0])
		{
			SendBFieldsToPlayers(true);
		}
	}
}

void DPlay::Process_PM_CSQuickRequest(ULong requestfrom)
{
	if (Host)
	{
			SendCSQuickStrucToPlayers(TRUE);

		if (GameType>TEAMPLAY)
			SendPilotsStatus(false,requestfrom);

		if (GameType==COMMSQUICKMISSION)
			SendCampaignStruc(true);
	}
}

void DPlay::Process_PM_SaveGame(char* message)
{
	if (!Host && H2H_Player[mySlot].status!=CPS_3D)
 		ReceiveSaveGame(false,((LPGENERIC)message)->PlayerID,((LPGENERIC)message)->Slot);

	if (H2H_Player[mySlot].status==CPS_FRAG)
		FragChanged=true;
}

void DPlay::Process_PM_Resync(char* message,ULong from)
{
	UByte slot=DPID2Slot(from);

	if (H2H_Player[mySlot].status==CPS_3D)
		ProcessResyncPacket((LPACSTATEPACKET)message,slot);
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		AddChatMessageToBuffer
//Date			Wed 22 Sep 1999
//------------------------------------------------------------------------------
void DPlay::AddChatMessageToBuffer(char* name, char* chat)
{
	strcpy(ChatBuffer.GetNext()->name,name);
	strcpy(ChatBuffer.GetNext()->chat,chat);

	ChatBuffer.AddEntryAndUpdateNext();

	if (ChatBuffer.GetNext()==ChatBuffer.GetCurr())
		ChatBuffer.UpdateCurr();
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		UpdateChatBox
//Date			Wed 22 Sep 1999
//------------------------------------------------------------------------------
void DPlay::UpdateChatBox()
{
	ChatBuffer.SetTempCurr();

	while (ChatBuffer.GetTemp()!=ChatBuffer.GetNext())
	{
		DisplayChatDialogue(ChatBuffer.GetTemp()->name,ChatBuffer.GetTemp()->chat);
		ChatBuffer.UpdateTemp();
	}
}

Bool DPlay::LobbyConnect()
{
	Bool res=TRUE;;
	
	if (lpDPL->ConnectEx(0,IID_IDirectPlay4A,(void**)&_DPlay.lpDP4,NULL)!=DP_OK)
		res=FALSE;

	if (!res)
	{
		lpDPL->Release();
		lpDPL=NULL;
		lpDP4=NULL;
	}
	else
	{
		res=_DPlay.SetUpPlayer();
	}

	return res;
}

void	DPlay::SendImHereMessage()
{
// send "I'm in with this slot" message

	UIPLAYERDATA uipd;

	H2H_Player[mySlot].status=CPS_READYROOM;

	CopyMemory(&(uipd.playerinfo),&H2H_Player[mySlot],sizeof(H2HPlayerInfo));

	uipd.PacketID=PID_IMHERE;
	uipd.Slot=mySlot;

	SendMessageToGroup((char*)&uipd,sizeof(UIPLAYERDATA));
}

void	DPlay::SendIDRequest()
{
	GENERIC g;

	g.PacketID=PID_IDREQUEST;

	SendMessageToGroup((char*)&g,sizeof(GENERIC));
}

void	DPlay::ProcessIDRequest()
{
	if (Implemented)
	{
		SendMyUniqueID(Persons2::PlayerSeenAC->uniqueID.count);
	}
}

bool DPlay::ValidService(char* name)
{
	char* temp1;
	char* temp2;
	bool valid=true;

	temp1=new char[strlen(name)+1];

	strcpy(temp1,name);

	for (temp2=temp1; temp2<temp1+strlen(temp1);temp2++)
	{
		*temp2=toupper(*temp2);
	}

// add similar string checks for other services we dont want in
// service list, i.e. all lobby only connections

	if (strstr(temp1,"MPLAYER")!=NULL)
	{
		valid=false;
	}
	else if (strstr(temp1,"WIREPLAY")!=NULL)
	{
		valid=false;
	}

	delete [] temp1;

	return valid;
}

void	DPlay::SendStatusChange(ULong status)
{
	GENERIC pack;

	if (status==CPS_MAP && !PlayerCreated)
		return;

	H2H_Player[mySlot].status=status;

	pack.PacketID=PID_STATUSCHANGE;
	pack.PlayerID=status;

	SendMessageToGroup((char*)&pack,sizeof(GENERIC));
}

bool	DPlay::ReceivePacketWithReRequest(ULong WantPID, ULong ReqPID, char*& packet, ULong& len, ULong to)
{
// inital wait for packet

	if (TimeoutReceive(WantPID,packet,len))
		return true;

// havent got packet in time
// resend request

	GENERIC p;

	p.PacketID=ReqPID;

// this will only be used once players are in game so can send to group rather
// than to all

	SendMessageToPlayer((char*)&p,sizeof(GENERIC),to);

// wait again

	if (TimeoutReceive(WantPID,packet,len))
		return true;

// no hope

	return false;
}

bool	DPlay::TimeoutReceive(ULong WantPID, char*& packet, ULong& len)
{
	ULong now=timeGetTime();
	char* RecPacket;
	ULong RecPacketLen=0,from;
	CommsTimeout time(now,(CommsTimeoutLength*2));

	while (!time.TimedOut(now))
	{
		if (ReceiveNextMessageToMe (RecPacket, RecPacketLen,from,DPRECEIVE_TOPLAYER))
		{
			if (from==DPID_SYSMSG)
			{
				ProcessSystemMessage(RecPacket);
			}
			else if (from!=aggID)
			{
				if(((LPGENERIC)RecPacket)->PacketID == WantPID)
				{
					packet=RecPacket;
					len=RecPacketLen;
					return true;
				}
				else
				{
					ProcessPlayerMessage(RecPacket,RecPacketLen,from);
				}
			}
		}
		now=timeGetTime();
	}
	return false;
}

bool	DPlay::SendMessageToGroup(char* data, ULong len, bool onego)
{
	return SendCommsMessage(data,len,playergroupID,onego);
}

bool	DPlay::SendMessageToPlayer(char* data, ULong len, ULong pid, bool onego)
{
	return SendCommsMessage(data,len,pid,onego);
}

bool	DPlay::SendRequestMessage(char* data, ULong len, bool onego)
{
	return SendCommsMessage(data,len,0,onego);
}

bool	DPlay::SendCommsMessage(char* data, ULong len, ULong to_id,bool onego)
{
	HRESULT res=DPERR_SENDTOOBIG;
	ULong now=timeGetTime();
	CommsTimeout time(now,CommsTimeoutLength);

// want to keep packets as small as possible, even if it means
// chopping them up into fragments

	if (!PlayerCreated)
		return false;

	if (csync || ResyncPhase || WorldSyncPhase)
	{
		res=lpDP4->SendEx (myDPlayID,to_id,DPSEND_ASYNC|DPSEND_NOSENDCOMPLETEMSG,data,len,0,0,NULL,NULL);
	}
	else
	{
		while (res!=DP_OK && res!=DPERR_PENDING && !onego)
		{
			now=timeGetTime();
			if (time.TimedOut(now)) 
			{
				return false;
			}

			{
// when we are not in the actual 3d game, then all packets should be
// sent guaranteed. <- full stop, period etc

				res=lpDP4->SendEx (myDPlayID,to_id,DPSEND_ASYNC|DPSEND_NOSENDCOMPLETEMSG|DPSEND_GUARANTEED,data,len,0,0,NULL,NULL);
			}
		}
	}

	return true;
}

void	DPlay::ProcessPlayerMessages()
{
	DWORD	BufferLen;
	char* Buffer;
	DPID	From=0;

	while (ReceiveNextMessageToMe(Buffer,BufferLen,From,DPRECEIVE_TOPLAYER))
	{
		if (From==DPID_SYSMSG)
		{
			ProcessSystemMessage(Buffer);
		}
		else if (From!=aggID)
		{
			ProcessPlayerMessage(Buffer,BufferLen,From);
		}
	}
}

void	DPlay::Process_PM_CSStruc(char* pack, bool init)
{
	ULong size,numparts;
	char* Buffer;
	ULong	BufferLen=0;
	ULong From,n;
	ULong rec=0;

	if (PlayerCreated && H2H_Player[mySlot].status==CPS_3D)
		return;

	if (!Host)
	{
		if (!init)
		{
// mission has changed, unassign all player slots

			for (n=0;n<MAXPLAYERS;n++)
			{
				H2H_Player[n].squadron=-1;
				H2H_Player[n].position=-1;
			}

			MMC.playersquadron=-1;
			MMC.playeracnum=-1;

			if (H2H_Player[mySlot].status==CPS_FRAG)
				FragChanged=true;

// want to update mission name

			DisplayInfo=TRUE;
		}
	}

	size=((LPGENERIC)pack)->Slot;
	numparts=((LPGENERIC)pack)->PlayerID;

// get parts

	UByte*	struc=new UByte[size];

	ULong now=timeGetTime();
	CommsTimeout time(now,(CommsTimeoutLength*2));

	while (rec!=numparts)
	{
		now=timeGetTime();

		if (time.TimedOut(now))
		{
			delete [] struc;
			return;
		}

		if (ReceiveNextMessageToMe (Buffer, BufferLen,From,DPRECEIVE_TOPLAYER))
		{
// if we are getting info about game initally dont bother with any other messages

			if (From!=0 && BufferLen!=sizeof(AGGSENDPACKET))
			{
				if(((LPGENERIC)Buffer)->PacketID == PID_CSSTRUCBINARY)
				{
					LPCSSTRUCPART csp=(LPCSSTRUCPART)Buffer;

					GameIndex=csp->newmissionnum;

					UByteP temp=struc;

					temp+=(csp->index)*500;

					CopyMemory(temp,csp->data,csp->size);

					rec++;
				}
			}
		}
	}

	UpdateCSQuick((UByte*)struc,GameIndex);

	delete [] struc;
}

bool	DPlay::GetAllGoResponses()
{
	char* Buffer;
	ULong	Buflen;
	UByte numresponses=0;
	LPGENERIC pack;
	ULong from;
	int n;

	ULong now=timeGetTime();
	CommsTimeout time(now,CommsTimeoutLength);

// check to see if all players are still in ready room

	if (!AllPlayersStillReady())
		return false;

	while (numresponses!=(CurrPlayers-1))
	{
		now=timeGetTime();

		if (time.TimedOut(now))
		{
			return FALSE;
		}

		if (ReceiveNextMessageToMe(Buffer,Buflen,from,DPRECEIVE_TOPLAYER))
		{
			if (from==0)
			{
// check to see if session has gone?

			}
			else
			{
				pack=(LPGENERIC)Buffer;

				if (pack->PacketID==PID_PLAYERLETSGO)
				{
					numresponses++;
				}
				else
				{
					ProcessPlayerMessage(Buffer,Buflen,from);

	// on every message received see if a players status has changed and if so
	// exit immediately

					if (!AllPlayersStillReady())
						return false;
				}
			}
		}
	}

	return true;
}

void	DPlay::SendGoResponse()
{
	GENERIC g;

	g.PacketID=PID_PLAYERLETSGO;

	SendMessageToGroup((char*)&g,sizeof(GENERIC));
}

bool	DPlay::GetHostGo()
{
	char* Buffer;
	ULong	Buflen;
	LPGENERIC pack;
	ULong from,n;
	bool gotgo=false;

// check to see if all players are still in ready room

	if (!AllPlayersStillReady())
		return false;

	ULong now=timeGetTime();
	CommsTimeout time(now,CommsTimeoutLength);

	while (!gotgo)
	{
		now=timeGetTime();

		if (time.TimedOut(now))
		{
			return FALSE;
		}

		if (ReceiveNextMessageToMe(Buffer,Buflen,from,DPRECEIVE_TOPLAYER))
		{
			if (from==0)
			{
// check to see if session has gone?

			}
			else
			{
				pack=(LPGENERIC)Buffer;

				if (pack->PacketID==PID_HOSTLETSGO)
				{
					gotgo=true;
				}
				else
				{
					ProcessPlayerMessage(Buffer,Buflen,from);

	// on every message received see if a players status has changed and if so
	// exit immediately

					if (!AllPlayersStillReady())
						return false;
				}
			}
		}
	}

	return true;
}

void	DPlay::SendHostGo()
{
	GENERIC g;

	g.PacketID=PID_HOSTLETSGO;

	SendMessageToGroup((char*)&g,sizeof(GENERIC));
}

void	DPlay::EmptyAggregatorQueue()
{
// keep aggregator message Q empty so that loads of messages dont get piled up in the UI

	char* Buffer;
	ULong From=aggID,BufferLen;

	while (ReceiveNextMessageToMe(Buffer,BufferLen,From,DPRECEIVE_FROMPLAYER))
	{
	}
}

bool	DPlay::AllPlayersStillReady()
{
	int n;

	for (n=0;n<MAXPLAYERS;n++)
	{						
		if (GameType<COMMSQUICKMISSION)
		{
			if (H2H_Player[n].status!=CPS_NONE && H2H_Player[n].status!=CPS_READYROOM)
			{
				return false;								
			}
		}
		else
		{
			if (H2H_Player[n].status!=CPS_NONE && H2H_Player[n].status!=CPS_FRAG)
			{
				return false;								
			}
		}
	}													
	return true;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		CheckPacketSizes
//Date			Wed 28 Oct 1998
//------------------------------------------------------------------------------
void	DPlay::CheckPacketSizes()
{
	ULong size=sizeof(ACPACKET);

	if (size==sizeof(INITINFO))
		_Error.SayAndQuit("INITINFO same size as ACPACKET");

	if (size==sizeof(PASSWORDPACK))
		_Error.SayAndQuit("PASSWORDPACK same size as ACPACKET");

	if (size==sizeof(GAMEDETAILS))
		_Error.SayAndQuit("GAMEDETAILS same size as ACPACKET");

	if (size==sizeof(SLOTPOSPACK))
		_Error.SayAndQuit("SLOTPOSPACK same size as ACPACKET");

	if (size==sizeof(UIPREFSDATA))
		_Error.SayAndQuit("UIPREFSDATA same size as ACPACKET");

	if (size==sizeof(ACSTATEPACKET))
		_Error.SayAndQuit("ACSTATEPACKET same size as ACPACKET");

	if (COMMSRADIOMESSAGELEN!=RADIOMESSAGELEN)
		_Error.SayAndQuit("Radio Message Length Changed to %d - change COMMS as well",RADIOMESSAGELEN);
}
